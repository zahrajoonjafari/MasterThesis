{"version":3,"file":"Aggregators.js","sourceRoot":"","sources":["../../lib/Aggregators.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport * as E from './expressions';\nimport { regularFunctions } from './functions';\nimport { number, string } from './functions/Helpers';\nimport { transformLiteral } from './Transformation';\nimport type { SetFunction } from './util/Consts';\nimport * as C from './util/Consts';\nimport { TypeURL } from './util/Consts';\nimport { parseXSDFloat } from './util/Parsing';\n\nconst DF = new DataFactory();\n\nexport abstract class BaseAggregator<State> {\n  protected distinct: boolean;\n  protected separator: string;\n\n  public constructor(expr: Algebra.AggregateExpression) {\n    this.distinct = expr.distinct;\n    this.separator = expr.separator || ' ';\n  }\n\n  public static emptyValue(): RDF.Term {\n    return undefined;\n  }\n\n  abstract init(start: RDF.Term): State;\n\n  abstract result(state: State): RDF.Term;\n\n  abstract put(state: State, bindings: RDF.Term): State;\n}\n\nclass Count extends BaseAggregator<number> {\n  public static emptyValue(): RDF.Term {\n    return number(0, TypeURL.XSD_INTEGER).toRDF();\n  }\n\n  public init(start: RDF.Term): number {\n    return 1;\n  }\n\n  public put(state: number, term: RDF.Term): number {\n    return state + 1;\n  }\n\n  public result(state: number): RDF.Term {\n    return number(state, TypeURL.XSD_INTEGER).toRDF();\n  }\n}\n\ntype SumState = E.NumericLiteral;\n\nclass Sum extends BaseAggregator<SumState> {\n  private readonly summer = regularFunctions[C.RegularOperator.ADDITION];\n\n  public static emptyValue(): RDF.Term {\n    return number(0, TypeURL.XSD_INTEGER).toRDF();\n  }\n\n  public init(start: RDF.Term): SumState {\n    const { value, type } = extractNumericValueAndTypeOrError(start);\n    return new E.NumericLiteral(value, DF.namedNode(type));\n  }\n\n  public put(state: SumState, term: RDF.Term): SumState {\n    const { value, type } = extractNumericValueAndTypeOrError(term);\n    const internalTerm = new E.NumericLiteral(value, DF.namedNode(type));\n    const sum = <E.NumericLiteral> this.summer.apply([ state, internalTerm ]);\n    return sum;\n  }\n\n  public result(state: SumState): RDF.Term {\n    return state.toRDF();\n  }\n}\n\ninterface IExtremeState {\n  extremeValue: number; term: RDF.Literal;\n}\n\nclass Min extends BaseAggregator<IExtremeState> {\n  public init(start: RDF.Term): IExtremeState {\n    const { value } = extractValue(null, start);\n    if (start.termType === 'Literal') {\n      return { extremeValue: value, term: start };\n    }\n  }\n\n  public put(state: IExtremeState, term: RDF.Term): IExtremeState {\n    const extracted = extractValue(state.term, term);\n    if (extracted.value < state.extremeValue && term.termType === 'Literal') {\n      return {\n        extremeValue: extracted.value,\n        term,\n      };\n    }\n    return state;\n  }\n\n  public result(state: IExtremeState): RDF.Term {\n    return state.term;\n  }\n}\n\nclass Max extends BaseAggregator<IExtremeState> {\n  public init(start: RDF.Term): IExtremeState {\n    const { value } = extractValue(null, start);\n    if (start.termType === 'Literal') {\n      return { extremeValue: value, term: start };\n    }\n  }\n\n  public put(state: IExtremeState, term: RDF.Term): IExtremeState {\n    const extracted = extractValue(state.term, term);\n    if (extracted.value > state.extremeValue && term.termType === 'Literal') {\n      return {\n        extremeValue: extracted.value,\n        term,\n      };\n    }\n    return state;\n  }\n\n  public result(state: IExtremeState): RDF.Term {\n    return state.term;\n  }\n}\n\ninterface IAverageState {\n  sum: E.NumericLiteral; count: number;\n}\n\nclass Average extends BaseAggregator<IAverageState> {\n  private readonly summer = regularFunctions[C.RegularOperator.ADDITION];\n  private readonly divider = regularFunctions[C.RegularOperator.DIVISION];\n\n  public static emptyValue(): RDF.Term {\n    return number(0, TypeURL.XSD_INTEGER).toRDF();\n  }\n\n  public init(start: RDF.Term): IAverageState {\n    const { value, type } = extractNumericValueAndTypeOrError(start);\n    const sum = new E.NumericLiteral(value, DF.namedNode(type));\n    return { sum, count: 1 };\n  }\n\n  public put(state: IAverageState, term: RDF.Term): IAverageState {\n    const { value, type } = extractNumericValueAndTypeOrError(term);\n    const internalTerm = new E.NumericLiteral(value, DF.namedNode(type));\n    const sum = <E.NumericLiteral> this.summer.apply([ state.sum, internalTerm ]);\n    return {\n      sum,\n      count: state.count + 1,\n    };\n  }\n\n  public result(state: IAverageState): RDF.Term {\n    const count = new E.NumericLiteral(state.count, DF.namedNode(C.TypeURL.XSD_INTEGER));\n    const result = this.divider.apply([ state.sum, count ]);\n    return result.toRDF();\n  }\n}\n\nclass GroupConcat extends BaseAggregator<string> {\n  public static emptyValue(): RDF.Term {\n    return string('').toRDF();\n  }\n\n  public init(start: RDF.Term): string {\n    return start.value;\n  }\n\n  public put(state: string, term: RDF.Term): string {\n    return state + this.separator + term.value;\n  }\n\n  public result(state: string): RDF.Term {\n    return string(state).toRDF();\n  }\n}\n\nclass Sample extends BaseAggregator<RDF.Term> {\n  public init(start: RDF.Term): RDF.Term {\n    return start;\n  }\n\n  public put(state: RDF.Term, term: RDF.Term): RDF.Term {\n    // First value is our sample\n    return state;\n  }\n\n  public result(state: RDF.Term): RDF.Term {\n    return state;\n  }\n}\n\nexport interface IAggregatorClass {\n  new(expr: Algebra.AggregateExpression): BaseAggregator<any>;\n\n  emptyValue: () => RDF.Term;\n}\n\nexport const aggregators: Readonly<{[key in SetFunction]: IAggregatorClass }> = {\n  count: Count,\n  sum: Sum,\n  min: Min,\n  max: Max,\n  avg: Average,\n  group_concat: GroupConcat,\n  sample: Sample,\n};\n\nfunction extractNumericValueAndTypeOrError(term: RDF.Term): { value: number; type: C.NumericTypeURL } {\n  // TODO: Check behaviour\n  if (term.termType !== 'Literal') {\n    throw new Error(`Term with value ${term.value} has type ${term.termType} and is not a numeric literal`);\n  } else if (!C.NumericTypeURLs.has(term.datatype.value)) {\n    throw new Error(`Term datatype ${term.datatype.value} with value ${term.value} has type ${term.termType} and is not a numeric literal`);\n  }\n\n  const type: C.NumericTypeURL = <C.NumericTypeURL> term.datatype.value;\n  const value = parseXSDFloat(term.value);\n  return { type, value };\n}\n\nfunction extractValue(extremeTerm: RDF.Literal, term: RDF.Term): { value: any; type: string } {\n  if (term.termType !== 'Literal') {\n    throw new Error(`Term with value ${term.value} has type ${term.termType} and is not a literal`);\n  }\n\n  const transformedLit = transformLiteral(term);\n  return { type: transformedLit.typeURL.value, value: transformedLit.typedValue };\n}\n"]}