{"version":3,"file":"AsyncAggregateEvaluator.js","sourceRoot":"","sources":["../../../lib/evaluators/AsyncAggregateEvaluator.ts"],"names":[],"mappings":";;;AAGA,qDAAkD;AAClD,qEAAkE;AAElE,MAAa,uBAAwB,SAAQ,+CAAsB;IAIjE,YAAmB,IAAiC,EAAE,MAA8B,EAAE,UAAoB;QACxG,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;QACxB,IAAI,CAAC,SAAS,GAAG,IAAI,+BAAc,CAAC,IAAI,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;QAC7D,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;IAC7B,CAAC;IAEM,GAAG,CAAC,QAAkB;QAC3B,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC7B,CAAC;IAES,KAAK,CAAC,KAAK,CAAC,QAAkB;QACtC,IAAI;YACF,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;YACrD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;SACpD;QAAC,OAAO,KAAc,EAAE;YACvB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SACvB;IACH,CAAC;IAES,SAAS,CAAC,GAAY;QAC9B,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,MAAM,GAAG,CAAC;SACX;aAAM;YACL,gEAAgE;YAChE,IAAI,CAAC,GAAG,GAAG,KAAK,IAAG,EAAE,GAAE,CAAC,CAAC;YACzB,wDAAwD;YACxD,IAAI,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC,SAAS,CAAC;YAC9B,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;SAC3B;IACH,CAAC;IAEO,KAAK,CAAC,IAAI,CAAC,KAAe;QAChC,IAAI;YACF,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACvD,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,aAAa,EAAE;gBACpC,OAAO;aACR;YACD,IAAI,IAAI,CAAC,KAAK,EAAE;gBACd,uGAAuG;gBACvG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;gBACxD,OAAO;aACR;YACD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAC7C,IAAI,IAAI,CAAC,KAAK,EAAE;gBACd,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACjC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACxC;SACF;QAAC,OAAO,KAAc,EAAE;YACvB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SACvB;IACH,CAAC;CACF;AAvDD,0DAuDC","sourcesContent":["import type { Algebra } from 'sparqlalgebrajs';\nimport type { Bindings } from '../Types';\nimport type { IAsyncEvaluatorConfig } from './AsyncEvaluator';\nimport { AsyncEvaluator } from './AsyncEvaluator';\nimport { BaseAggregateEvaluator } from './BaseAggregateEvaluator';\n\nexport class AsyncAggregateEvaluator extends BaseAggregateEvaluator {\n  private readonly evaluator: AsyncEvaluator;\n  private errorOccurred: boolean;\n\n  public constructor(expr: Algebra.AggregateExpression, config?: IAsyncEvaluatorConfig, throwError?: boolean) {\n    super(expr, throwError);\n    this.evaluator = new AsyncEvaluator(expr.expression, config);\n    this.errorOccurred = false;\n  }\n\n  public put(bindings: Bindings): Promise<void> {\n    return this.init(bindings);\n  }\n\n  protected async __put(bindings: Bindings): Promise<void> {\n    try {\n      const term = await this.evaluator.evaluate(bindings);\n      this.state = this.aggregator.put(this.state, term);\n    } catch (error: unknown) {\n      this.safeThrow(error);\n    }\n  }\n\n  protected safeThrow(err: unknown): void {\n    if (this.throwError) {\n      throw err;\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n      this.put = async() => {};\n      // eslint-disable-next-line unicorn/no-useless-undefined\n      this.result = () => undefined;\n      this.errorOccurred = true;\n    }\n  }\n\n  private async init(start: Bindings): Promise<void> {\n    try {\n      const startTerm = await this.evaluator.evaluate(start);\n      if (!startTerm || this.errorOccurred) {\n        return;\n      }\n      if (this.state) {\n        // Another put already initialized this, we should just handle the put as in __put and not init anymore\n        this.state = this.aggregator.put(this.state, startTerm);\n        return;\n      }\n      this.state = this.aggregator.init(startTerm);\n      if (this.state) {\n        this.put = this.__put.bind(this);\n        this.result = this.__result.bind(this);\n      }\n    } catch (error: unknown) {\n      this.safeThrow(error);\n    }\n  }\n}\n"]}