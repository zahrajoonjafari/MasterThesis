{"version":3,"file":"SyncEvaluator.js","sourceRoot":"","sources":["../../../lib/evaluators/SyncEvaluator.ts"],"names":[],"mappings":";;;AAKA,sDAAqD;AAGrD,iFAAwE;AAsBxE,MAAa,aAAa;IAIxB,YAA0B,OAAuB,EAAS,SAA+B,EAAE;QAAjE,YAAO,GAAP,OAAO,CAAgB;QAAS,WAAM,GAAN,MAAM,CAA2B;QACzF,MAAM,OAAO,GAAyB;YACpC,GAAG,EAAE,MAAM,CAAC,GAAG,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;YACvC,KAAK,EAAE,MAAM,CAAC,KAAK,IAAI,SAAS;YAChC,OAAO,EAAE,MAAM,CAAC,OAAO,IAAI,SAAS;YACpC,MAAM,EAAE,MAAM,CAAC,MAAM;YACrB,SAAS,EAAE,MAAM,CAAC,SAAS;SAC5B,CAAC;QAEF,MAAM,wBAAwB;QAC5B,wDAAwD;QACxD,MAAM,CAAC,wBAAwB,IAAI,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC;QACvD,IAAI,CAAC,IAAI,GAAG,IAAA,iCAAgB,EAAC,OAAO,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,wBAAwB,EAAE,CAAC,CAAC;QAC3F,IAAI,CAAC,SAAS,GAAG,IAAI,qDAAsB,CAAC,OAAO,CAAC,CAAC;IACvD,CAAC;IAEM,QAAQ,CAAC,OAAiB;QAC/B,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC3D,OAAO,MAAM,CAAC,KAAK,EAAE,CAAC;IACxB,CAAC;IAEM,aAAa,CAAC,OAAiB;QACpC,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC3D,OAAO,MAAM,CAAC,SAAS,EAAE,CAAC;IAC5B,CAAC;IAEM,kBAAkB,CAAC,OAAiB;QACzC,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC3D,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AAlCD,sCAkCC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra as Alg } from 'sparqlalgebrajs';\n\nimport type * as E from '../expressions/Expressions';\n\nimport { transformAlgebra } from '../Transformation';\nimport type { Bindings, IExpressionEvaluator } from '../Types';\n\nimport { SyncRecursiveEvaluator } from './RecursiveExpressionEvaluator';\n\ntype Expression = E.Expression;\ntype Term = E.TermExpression;\n\nexport interface ISyncEvaluatorConfig {\n  now?: Date;\n  baseIRI?: string;\n\n  exists?: (expression: Alg.ExistenceExpression, mapping: Bindings) => boolean;\n  aggregate?: (expression: Alg.AggregateExpression) => RDF.Term;\n  bnode?: (input?: string) => RDF.BlankNode;\n  extensionFunctionCreator?: SyncExtensionFunctionCreator;\n}\n\nexport type SyncExtensionFunction = (args: RDF.Term[]) => RDF.Term;\nexport type SyncExtensionFunctionCreator = (functionNamedNode: RDF.NamedNode) => SyncExtensionFunction | undefined;\n\nexport type SyncEvaluatorContext = ISyncEvaluatorConfig & {\n  now: Date;\n};\n\nexport class SyncEvaluator {\n  private readonly expr: Expression;\n  private readonly evaluator: IExpressionEvaluator<Expression, Term>;\n\n  public constructor(public algExpr: Alg.Expression, public config: ISyncEvaluatorConfig = {}) {\n    const context: SyncEvaluatorContext = {\n      now: config.now || new Date(Date.now()),\n      bnode: config.bnode || undefined,\n      baseIRI: config.baseIRI || undefined,\n      exists: config.exists,\n      aggregate: config.aggregate,\n    };\n\n    const extensionFunctionCreator: SyncExtensionFunctionCreator =\n      // eslint-disable-next-line unicorn/no-useless-undefined\n      config.extensionFunctionCreator || (() => undefined);\n    this.expr = transformAlgebra(algExpr, { type: 'sync', creator: extensionFunctionCreator });\n    this.evaluator = new SyncRecursiveEvaluator(context);\n  }\n\n  public evaluate(mapping: Bindings): RDF.Term {\n    const result = this.evaluator.evaluate(this.expr, mapping);\n    return result.toRDF();\n  }\n\n  public evaluateAsEBV(mapping: Bindings): boolean {\n    const result = this.evaluator.evaluate(this.expr, mapping);\n    return result.coerceEBV();\n  }\n\n  public evaluateAsInternal(mapping: Bindings): Term {\n    const result = this.evaluator.evaluate(this.expr, mapping);\n    return result;\n  }\n}\n"]}