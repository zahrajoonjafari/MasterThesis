{"version":3,"file":"RecursiveExpressionEvaluator.js","sourceRoot":"","sources":["../../../lib/evaluators/RecursiveExpressionEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["import * as E from '../expressions';\nimport type { AsyncExtension, SyncExtension } from '../expressions';\nimport { transformRDFTermUnsafe } from '../Transformation';\nimport type { Bindings, IExpressionEvaluator } from '../Types';\nimport * as Err from '../util/Errors';\n\nimport type { AsyncEvaluatorContext } from './AsyncEvaluator';\nimport type { SyncEvaluatorContext } from './SyncEvaluator';\n\ntype Expression = E.Expression;\ntype Term = E.TermExpression;\ntype Variable = E.VariableExpression;\ntype Existence = E.ExistenceExpression;\ntype Operator = E.OperatorExpression;\ntype SpecialOperator = E.SpecialOperatorExpression;\ntype Named = E.NamedExpression;\ntype Aggregate = E.AggregateExpression;\n\nconst sharedEvaluators = {\n  term(expr: Term, mapping: Bindings): Term {\n    return expr;\n  },\n  variable(expr: Variable, mapping: Bindings): Term {\n    const term = mapping.get(expr.name);\n    if (!term) {\n      throw new Err.UnboundVariableError(expr.name, mapping);\n    }\n    return transformRDFTermUnsafe(term);\n  },\n};\n\nexport class AsyncRecursiveEvaluator implements IExpressionEvaluator<Expression, Promise<Term>> {\n  private readonly subEvaluators: Record<string, (expr: Expression, mapping: Bindings) => Promise<Term> | Term> = {\n    // Shared\n    [E.ExpressionType.Term]: sharedEvaluators.term.bind(this),\n    [E.ExpressionType.Variable]: sharedEvaluators.variable.bind(this),\n\n    // Async\n    [E.ExpressionType.Operator]: this.evalOperator.bind(this),\n    [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator.bind(this),\n    [E.ExpressionType.Named]: this.evalNamed.bind(this),\n    [E.ExpressionType.Existence]: this.evalExistence.bind(this),\n    [E.ExpressionType.Aggregate]: this.evalAggregate.bind(this),\n    [E.ExpressionType.AsyncExtension]: this.evalAsyncExtension.bind(this),\n  };\n\n  public constructor(private readonly context: AsyncEvaluatorContext) { }\n\n  public async evaluate(expr: Expression, mapping: Bindings): Promise<Term> {\n    const evaluator = this.subEvaluators[expr.expressionType];\n    if (!evaluator) {\n      throw new Err.InvalidExpressionType(expr);\n    }\n    return evaluator.bind(this)(expr, mapping);\n  }\n\n  private async evalOperator(expr: Operator, mapping: Bindings): Promise<Term> {\n    const argPromises = expr.args.map(arg => this.evaluate(arg, mapping));\n    const argResults = await Promise.all(argPromises);\n    return expr.apply(argResults);\n  }\n\n  private async evalSpecialOperator(expr: SpecialOperator, mapping: Bindings): Promise<Term> {\n    const evaluate = this.evaluate.bind(this);\n    const context = {\n      args: expr.args,\n      mapping,\n      evaluate,\n      context: {\n        now: this.context.now,\n        baseIRI: this.context.baseIRI,\n        bnode: this.context.bnode,\n      },\n    };\n    return expr.applyAsync(context);\n  }\n\n  private async _evalAsyncArgs(args: Expression[], mapping: Bindings): Promise<E.TermExpression[]> {\n    const argPromises = args.map(arg => this.evaluate(arg, mapping));\n    return await Promise.all(argPromises);\n  }\n\n  private async evalNamed(expr: Named, mapping: Bindings): Promise<Term> {\n    return expr.apply(await this._evalAsyncArgs(expr.args, mapping));\n  }\n\n  private async evalAsyncExtension(expr: AsyncExtension, mapping: Bindings): Promise<Term> {\n    return await expr.apply(await this._evalAsyncArgs(expr.args, mapping));\n  }\n\n  private async evalExistence(expr: Existence, mapping: Bindings): Promise<Term> {\n    if (!this.context.exists) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return new E.BooleanLiteral(await this\n      .context\n      .exists(expr.expression, mapping));\n  }\n\n  // TODO: Remove?\n  private async evalAggregate(expr: Aggregate, _mapping: Bindings): Promise<Term> {\n    if (!this.context.aggregate) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return transformRDFTermUnsafe(await this\n      .context\n      .aggregate(expr.expression));\n  }\n}\n\nexport class SyncRecursiveEvaluator implements IExpressionEvaluator<Expression, Term> {\n  private readonly subEvaluators: Record<string, (expr: Expression, mapping: Bindings) => Term> = {\n    // Shared\n    [E.ExpressionType.Term]: sharedEvaluators.term.bind(this),\n    [E.ExpressionType.Variable]: sharedEvaluators.variable.bind(this),\n\n    // Sync\n    [E.ExpressionType.Operator]: this.evalOperator.bind(this),\n    [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator.bind(this),\n    [E.ExpressionType.Named]: this.evalNamed.bind(this),\n    [E.ExpressionType.Existence]: this.evalExistence.bind(this),\n    [E.ExpressionType.Aggregate]: this.evalAggregate.bind(this),\n    [E.ExpressionType.SyncExtension]: this.evalSyncExtension.bind(this),\n  };\n\n  public constructor(private readonly context: SyncEvaluatorContext) { }\n\n  public evaluate(expr: Expression, mapping: Bindings): Term {\n    const evaluator = this.subEvaluators[expr.expressionType];\n    if (!evaluator) {\n      throw new Err.InvalidExpressionType(expr);\n    }\n    return evaluator.bind(this)(expr, mapping);\n  }\n\n  private evalOperator(expr: Operator, mapping: Bindings): Term {\n    const args = expr.args.map(arg => this.evaluate(arg, mapping));\n    return expr.apply(args);\n  }\n\n  private evalSpecialOperator(expr: SpecialOperator, mapping: Bindings): Term {\n    const evaluate = this.evaluate.bind(this);\n    const context = {\n      args: expr.args,\n      mapping,\n      evaluate,\n      context: {\n        now: this.context.now,\n        baseIRI: this.context.baseIRI,\n        bnode: this.context.bnode,\n      },\n    };\n    return expr.applySync(context);\n  }\n\n  private evalNamed(expr: Named, mapping: Bindings): Term {\n    const args = expr.args.map(arg => this.evaluate(arg, mapping));\n    return expr.apply(args);\n  }\n\n  private evalSyncExtension(expr: SyncExtension, mapping: Bindings): Term {\n    const args = expr.args.map(arg => this.evaluate(arg, mapping));\n    return expr.apply(args);\n  }\n\n  private evalExistence(expr: Existence, mapping: Bindings): Term {\n    if (!this.context.exists) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return new E.BooleanLiteral(this\n      .context\n      .exists(expr.expression, mapping));\n  }\n\n  private evalAggregate(expr: Aggregate, mapping: Bindings): Term {\n    if (!this.context.aggregate) {\n      throw new Err.NoAggregator();\n    }\n\n    return transformRDFTermUnsafe(this\n      .context\n      .aggregate(expr.expression));\n  }\n}\n"]}