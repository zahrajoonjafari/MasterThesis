{"version":3,"file":"AsyncEvaluator.js","sourceRoot":"","sources":["../../../lib/evaluators/AsyncEvaluator.ts"],"names":[],"mappings":";;;AAKA,sDAAqD;AAGrD,iFAAyE;AAsBzE,MAAa,cAAc;IAIzB,YAA0B,OAAuB,EAAS,SAAgC,EAAE;QAAlE,YAAO,GAAP,OAAO,CAAgB;QAAS,WAAM,GAAN,MAAM,CAA4B;QAC1F,MAAM,OAAO,GAAG;YACd,GAAG,EAAE,MAAM,CAAC,GAAG,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;YACvC,KAAK,EAAE,MAAM,CAAC,KAAK,IAAI,SAAS;YAChC,OAAO,EAAE,MAAM,CAAC,OAAO,IAAI,SAAS;YACpC,MAAM,EAAE,MAAM,CAAC,MAAM;YACrB,SAAS,EAAE,MAAM,CAAC,SAAS;SAC5B,CAAC;QAEF,MAAM,wBAAwB;QAC5B,wDAAwD;QACxD,MAAM,CAAC,wBAAwB,IAAI,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC;QACvD,IAAI,CAAC,IAAI,GAAG,IAAA,iCAAgB,EAAC,OAAO,EAAE,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,wBAAwB,EAAE,CAAC,CAAC;QAE5F,IAAI,CAAC,SAAS,GAAG,IAAI,sDAAuB,CAAC,OAAO,CAAC,CAAC;IACxD,CAAC;IAEM,KAAK,CAAC,QAAQ,CAAC,OAAiB;QACrC,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACjE,OAAO,MAAM,CAAC,KAAK,EAAE,CAAC;IACxB,CAAC;IAEM,KAAK,CAAC,aAAa,CAAC,OAAiB;QAC1C,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACjE,OAAO,MAAM,CAAC,SAAS,EAAE,CAAC;IAC5B,CAAC;IAEM,KAAK,CAAC,kBAAkB,CAAC,OAAiB;QAC/C,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACjE,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AAnCD,wCAmCC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra as Alg } from 'sparqlalgebrajs';\n\nimport type * as E from '../expressions/Expressions';\n\nimport { transformAlgebra } from '../Transformation';\nimport type { Bindings, IExpressionEvaluator } from '../Types';\n\nimport { AsyncRecursiveEvaluator } from './RecursiveExpressionEvaluator';\n\ntype Expression = E.Expression;\ntype Term = E.TermExpression;\n\nexport type AsyncExtensionFunction = (args: RDF.Term[]) => Promise<RDF.Term>;\nexport type AsyncExtensionFunctionCreator = (functionNamedNode: RDF.NamedNode) => AsyncExtensionFunction | undefined;\n\nexport interface IAsyncEvaluatorConfig {\n  now?: Date;\n  baseIRI?: string;\n\n  exists?: (expression: Alg.ExistenceExpression, mapping: Bindings) => Promise<boolean>;\n  aggregate?: (expression: Alg.AggregateExpression) => Promise<RDF.Term>;\n  bnode?: (input?: string) => Promise<RDF.BlankNode>;\n  extensionFunctionCreator?: AsyncExtensionFunctionCreator;\n}\n\nexport type AsyncEvaluatorContext = IAsyncEvaluatorConfig & {\n  now: Date;\n};\n\nexport class AsyncEvaluator {\n  private readonly expr: Expression;\n  private readonly evaluator: IExpressionEvaluator<Expression, Promise<Term>>;\n\n  public constructor(public algExpr: Alg.Expression, public config: IAsyncEvaluatorConfig = {}) {\n    const context = {\n      now: config.now || new Date(Date.now()),\n      bnode: config.bnode || undefined,\n      baseIRI: config.baseIRI || undefined,\n      exists: config.exists,\n      aggregate: config.aggregate,\n    };\n\n    const extensionFunctionCreator: AsyncExtensionFunctionCreator =\n      // eslint-disable-next-line unicorn/no-useless-undefined\n      config.extensionFunctionCreator || (() => undefined);\n    this.expr = transformAlgebra(algExpr, { type: 'async', creator: extensionFunctionCreator });\n\n    this.evaluator = new AsyncRecursiveEvaluator(context);\n  }\n\n  public async evaluate(mapping: Bindings): Promise<RDF.Term> {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return result.toRDF();\n  }\n\n  public async evaluateAsEBV(mapping: Bindings): Promise<boolean> {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return result.coerceEBV();\n  }\n\n  public async evaluateAsInternal(mapping: Bindings): Promise<Term> {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return result;\n  }\n}\n"]}