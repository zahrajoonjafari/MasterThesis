"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformExistence = exports.transformAggregate = exports.transformLiteral = exports.transformRDFTermUnsafe = exports.transformAlgebra = void 0;
const RDFString = require("rdf-string");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const E = require("./expressions");
const functions_1 = require("./functions");
const C = require("./util/Consts");
const Consts_1 = require("./util/Consts");
const Err = require("./util/Errors");
const Errors_1 = require("./util/Errors");
const P = require("./util/Parsing");
function transformAlgebra(expr, creatorConfig) {
    if (!expr) {
        throw new Err.InvalidExpression(expr);
    }
    const types = sparqlalgebrajs_1.Algebra.expressionTypes;
    switch (expr.expressionType) {
        case types.TERM:
            return transformTerm(expr);
        case types.OPERATOR:
            return transformOperator(expr, creatorConfig);
        case types.NAMED:
            return transformNamed(expr, creatorConfig);
        case types.EXISTENCE:
            return transformExistence(expr);
        case types.AGGREGATE:
            return transformAggregate(expr);
        case types.WILDCARD:
            return transformWildcard(expr);
        default: throw new Err.InvalidExpressionType(expr);
    }
}
exports.transformAlgebra = transformAlgebra;
/**
 * Transforms an RDF term to the internal representation of a term,
 * assuming it is not a variable, which would be an expression (internally).
 *
 * @param term RDF term to transform into internal representation of a term
 */
function transformRDFTermUnsafe(term) {
    return transformTerm({
        term,
        type: 'expression',
        expressionType: 'term',
    });
}
exports.transformRDFTermUnsafe = transformRDFTermUnsafe;
function transformTerm(term) {
    if (!term.term) {
        throw new Err.InvalidExpression(term);
    }
    switch (term.term.termType) {
        case 'Variable': return new E.Variable(RDFString.termToString(term.term));
        case 'Literal': return transformLiteral(term.term);
        case 'NamedNode': return new E.NamedNode(term.term.value);
        case 'BlankNode': return new E.BlankNode(term.term.value);
        default: throw new Err.InvalidTermType(term);
    }
}
function transformWildcard(term) {
    if (!term.wildcard) {
        throw new Err.InvalidExpression(term);
    }
    return new E.NamedNode(term.wildcard.value);
}
// TODO: Maybe do this with a map?
function transformLiteral(lit) {
    if (!lit.datatype) {
        return lit.language ?
            new E.LangStringLiteral(lit.value, lit.language) :
            new E.StringLiteral(lit.value);
    }
    switch (lit.datatype.value) {
        case null:
        case undefined:
        case '': {
            return lit.language ?
                new E.LangStringLiteral(lit.value, lit.language) :
                new E.StringLiteral(lit.value);
        }
        case Consts_1.TypeURL.XSD_STRING:
            return new E.StringLiteral(lit.value);
        case Consts_1.TypeURL.RDF_LANG_STRING:
            return new E.LangStringLiteral(lit.value, lit.language);
        case Consts_1.TypeURL.XSD_DATE_TIME:
        case Consts_1.TypeURL.XSD_DATE: {
            const dateVal = new Date(lit.value);
            if (Number.isNaN(dateVal.getTime())) {
                return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);
            }
            return new E.DateTimeLiteral(new Date(lit.value), lit.value);
        }
        case Consts_1.TypeURL.XSD_BOOLEAN: {
            if (lit.value !== 'true' && lit.value !== 'false' && lit.value !== '1' && lit.value !== '0') {
                return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);
            }
            return new E.BooleanLiteral(lit.value === 'true' || lit.value === '1', lit.value);
        }
        case Consts_1.TypeURL.XSD_INTEGER:
        case Consts_1.TypeURL.XSD_DECIMAL:
        case Consts_1.TypeURL.XSD_NEGATIVE_INTEGER:
        case Consts_1.TypeURL.XSD_NON_NEGATIVE_INTEGER:
        case Consts_1.TypeURL.XSD_NON_POSITIVE_INTEGER:
        case Consts_1.TypeURL.XSD_POSITIVE_INTEGER:
        case Consts_1.TypeURL.XSD_LONG:
        case Consts_1.TypeURL.XSD_SHORT:
        case Consts_1.TypeURL.XSD_BYTE:
        case Consts_1.TypeURL.XSD_UNSIGNED_LONG:
        case Consts_1.TypeURL.XSD_UNSIGNED_INT:
        case Consts_1.TypeURL.XSD_UNSIGNED_SHORT:
        case Consts_1.TypeURL.XSD_UNSIGNED_BYTE:
        case Consts_1.TypeURL.XSD_INT: {
            const intVal = P.parseXSDDecimal(lit.value);
            if (intVal === undefined) {
                return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);
            }
            return new E.NumericLiteral(intVal, lit.datatype, lit.value);
        }
        case Consts_1.TypeURL.XSD_FLOAT:
        case Consts_1.TypeURL.XSD_DOUBLE: {
            const doubleVal = P.parseXSDFloat(lit.value);
            if (doubleVal === undefined) {
                return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);
            }
            return new E.NumericLiteral(doubleVal, lit.datatype, lit.value);
        }
        default: return new E.Literal(lit.value, lit.datatype, lit.value);
    }
}
exports.transformLiteral = transformLiteral;
function transformOperator(expr, creatorConfig) {
    if (C.SpecialOperators.has(expr.operator)) {
        const specialOp = expr.operator;
        const specialArgs = expr.args.map(arg => transformAlgebra(arg, creatorConfig));
        const specialFunc = functions_1.specialFunctions[specialOp];
        if (!specialFunc.checkArity(specialArgs)) {
            throw new Err.InvalidArity(specialArgs, specialOp);
        }
        return new E.SpecialOperator(specialArgs, specialFunc.applyAsync, specialFunc.applySync);
    }
    if (!C.Operators.has(expr.operator)) {
        throw new Err.UnknownOperator(expr.operator);
    }
    const regularOp = expr.operator;
    const regularArgs = expr.args.map(arg => transformAlgebra(arg, creatorConfig));
    const regularFunc = functions_1.regularFunctions[regularOp];
    if (!hasCorrectArity(regularArgs, regularFunc.arity)) {
        throw new Err.InvalidArity(regularArgs, regularOp);
    }
    return new E.Operator(regularArgs, regularFunc.apply);
}
function wrapSyncFunction(func, name) {
    return args => {
        try {
            const res = func(args.map(arg => arg.toRDF()));
            return transformRDFTermUnsafe(res);
        }
        catch (error) {
            throw new Errors_1.ExtensionFunctionError(name, error);
        }
    };
}
function wrapAsyncFunction(func, name) {
    return async (args) => {
        try {
            const res = await func(args.map(arg => arg.toRDF()));
            return transformRDFTermUnsafe(res);
        }
        catch (error) {
            throw new Errors_1.ExtensionFunctionError(name, error);
        }
    };
}
// TODO: Support passing functions to override default behaviour;
function transformNamed(expr, creatorConfig) {
    const funcName = expr.name.value;
    const args = expr.args.map(arg => transformAlgebra(arg, creatorConfig));
    if (C.NamedOperators.has(funcName)) {
        // Return a basic named expression
        const op = expr.name.value;
        const namedFunc = functions_1.namedFunctions[op];
        return new E.Named(expr.name, args, namedFunc.apply);
    }
    if (creatorConfig.type === 'sync') {
        // Expression might be extension function, check this for the sync
        const syncExtensionFunc = creatorConfig.creator(expr.name);
        if (syncExtensionFunc) {
            const simpleAppl = wrapSyncFunction(syncExtensionFunc, expr.name.value);
            return new E.SyncExtension(expr.name, args, simpleAppl);
        }
    }
    else {
        // The expression might be an extension function, check this for the async case
        const asyncExtensionFunc = creatorConfig.creator(expr.name);
        if (asyncExtensionFunc) {
            const asyncAppl = wrapAsyncFunction(asyncExtensionFunc, expr.name.value);
            return new E.AsyncExtension(expr.name, args, asyncAppl);
        }
    }
    throw new Err.UnknownNamedOperator(expr.name.value);
}
function hasCorrectArity(args, arity) {
    // Infinity is used to represent var-args, so it's always correct.
    if (arity === Number.POSITIVE_INFINITY) {
        return true;
    }
    // If the function has overloaded arity, the actual arity needs to be present.
    if (Array.isArray(arity)) {
        return arity.includes(args.length);
    }
    return args.length === arity;
}
function transformAggregate(expr) {
    const name = expr.aggregator;
    return new E.Aggregate(name, expr);
}
exports.transformAggregate = transformAggregate;
function transformExistence(expr) {
    return new E.Existence(expr);
}
exports.transformExistence = transformExistence;
//# sourceMappingURL=Transformation.js.map