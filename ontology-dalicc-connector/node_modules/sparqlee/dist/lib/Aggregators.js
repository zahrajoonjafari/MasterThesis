"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.aggregators = exports.BaseAggregator = void 0;
const rdf_data_factory_1 = require("rdf-data-factory");
const E = require("./expressions");
const functions_1 = require("./functions");
const Helpers_1 = require("./functions/Helpers");
const Transformation_1 = require("./Transformation");
const C = require("./util/Consts");
const Consts_1 = require("./util/Consts");
const Parsing_1 = require("./util/Parsing");
const DF = new rdf_data_factory_1.DataFactory();
class BaseAggregator {
    constructor(expr) {
        this.distinct = expr.distinct;
        this.separator = expr.separator || ' ';
    }
    static emptyValue() {
        return undefined;
    }
}
exports.BaseAggregator = BaseAggregator;
class Count extends BaseAggregator {
    static emptyValue() {
        return (0, Helpers_1.number)(0, Consts_1.TypeURL.XSD_INTEGER).toRDF();
    }
    init(start) {
        return 1;
    }
    put(state, term) {
        return state + 1;
    }
    result(state) {
        return (0, Helpers_1.number)(state, Consts_1.TypeURL.XSD_INTEGER).toRDF();
    }
}
class Sum extends BaseAggregator {
    constructor() {
        super(...arguments);
        this.summer = functions_1.regularFunctions[C.RegularOperator.ADDITION];
    }
    static emptyValue() {
        return (0, Helpers_1.number)(0, Consts_1.TypeURL.XSD_INTEGER).toRDF();
    }
    init(start) {
        const { value, type } = extractNumericValueAndTypeOrError(start);
        return new E.NumericLiteral(value, DF.namedNode(type));
    }
    put(state, term) {
        const { value, type } = extractNumericValueAndTypeOrError(term);
        const internalTerm = new E.NumericLiteral(value, DF.namedNode(type));
        const sum = this.summer.apply([state, internalTerm]);
        return sum;
    }
    result(state) {
        return state.toRDF();
    }
}
class Min extends BaseAggregator {
    init(start) {
        const { value } = extractValue(null, start);
        if (start.termType === 'Literal') {
            return { extremeValue: value, term: start };
        }
    }
    put(state, term) {
        const extracted = extractValue(state.term, term);
        if (extracted.value < state.extremeValue && term.termType === 'Literal') {
            return {
                extremeValue: extracted.value,
                term,
            };
        }
        return state;
    }
    result(state) {
        return state.term;
    }
}
class Max extends BaseAggregator {
    init(start) {
        const { value } = extractValue(null, start);
        if (start.termType === 'Literal') {
            return { extremeValue: value, term: start };
        }
    }
    put(state, term) {
        const extracted = extractValue(state.term, term);
        if (extracted.value > state.extremeValue && term.termType === 'Literal') {
            return {
                extremeValue: extracted.value,
                term,
            };
        }
        return state;
    }
    result(state) {
        return state.term;
    }
}
class Average extends BaseAggregator {
    constructor() {
        super(...arguments);
        this.summer = functions_1.regularFunctions[C.RegularOperator.ADDITION];
        this.divider = functions_1.regularFunctions[C.RegularOperator.DIVISION];
    }
    static emptyValue() {
        return (0, Helpers_1.number)(0, Consts_1.TypeURL.XSD_INTEGER).toRDF();
    }
    init(start) {
        const { value, type } = extractNumericValueAndTypeOrError(start);
        const sum = new E.NumericLiteral(value, DF.namedNode(type));
        return { sum, count: 1 };
    }
    put(state, term) {
        const { value, type } = extractNumericValueAndTypeOrError(term);
        const internalTerm = new E.NumericLiteral(value, DF.namedNode(type));
        const sum = this.summer.apply([state.sum, internalTerm]);
        return {
            sum,
            count: state.count + 1,
        };
    }
    result(state) {
        const count = new E.NumericLiteral(state.count, DF.namedNode(C.TypeURL.XSD_INTEGER));
        const result = this.divider.apply([state.sum, count]);
        return result.toRDF();
    }
}
class GroupConcat extends BaseAggregator {
    static emptyValue() {
        return (0, Helpers_1.string)('').toRDF();
    }
    init(start) {
        return start.value;
    }
    put(state, term) {
        return state + this.separator + term.value;
    }
    result(state) {
        return (0, Helpers_1.string)(state).toRDF();
    }
}
class Sample extends BaseAggregator {
    init(start) {
        return start;
    }
    put(state, term) {
        // First value is our sample
        return state;
    }
    result(state) {
        return state;
    }
}
exports.aggregators = {
    count: Count,
    sum: Sum,
    min: Min,
    max: Max,
    avg: Average,
    group_concat: GroupConcat,
    sample: Sample,
};
function extractNumericValueAndTypeOrError(term) {
    // TODO: Check behaviour
    if (term.termType !== 'Literal') {
        throw new Error(`Term with value ${term.value} has type ${term.termType} and is not a numeric literal`);
    }
    else if (!C.NumericTypeURLs.has(term.datatype.value)) {
        throw new Error(`Term datatype ${term.datatype.value} with value ${term.value} has type ${term.termType} and is not a numeric literal`);
    }
    const type = term.datatype.value;
    const value = (0, Parsing_1.parseXSDFloat)(term.value);
    return { type, value };
}
function extractValue(extremeTerm, term) {
    if (term.termType !== 'Literal') {
        throw new Error(`Term with value ${term.value} has type ${term.termType} and is not a literal`);
    }
    const transformedLit = (0, Transformation_1.transformLiteral)(term);
    return { type: transformedLit.typeURL.value, value: transformedLit.typedValue };
}
//# sourceMappingURL=Aggregators.js.map