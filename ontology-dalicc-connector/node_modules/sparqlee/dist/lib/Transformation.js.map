{"version":3,"file":"Transformation.js","sourceRoot":"","sources":["../../lib/Transformation.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport * as RDFString from 'rdf-string';\nimport { Algebra as Alg } from 'sparqlalgebrajs';\n\nimport type { AsyncExtensionFunction, AsyncExtensionFunctionCreator } from './evaluators/AsyncEvaluator';\nimport type { SyncExtensionFunction, SyncExtensionFunctionCreator } from './evaluators/SyncEvaluator';\nimport * as E from './expressions';\nimport type { AsyncExtensionApplication, SimpleApplication } from './expressions';\nimport { namedFunctions, regularFunctions, specialFunctions } from './functions';\nimport * as C from './util/Consts';\nimport { TypeURL as DT } from './util/Consts';\nimport * as Err from './util/Errors';\nimport { ExtensionFunctionError } from './util/Errors';\nimport * as P from './util/Parsing';\n\ntype FunctionCreatorConfig = { type: 'sync'; creator: SyncExtensionFunctionCreator } |\n{ type: 'async'; creator: AsyncExtensionFunctionCreator };\n\nexport function transformAlgebra(expr: Alg.Expression, creatorConfig: FunctionCreatorConfig): E.Expression {\n  if (!expr) {\n    throw new Err.InvalidExpression(expr);\n  }\n  const types = Alg.expressionTypes;\n\n  switch (expr.expressionType) {\n    case types.TERM:\n      return transformTerm(<Alg.TermExpression> expr);\n    case types.OPERATOR:\n      return transformOperator(<Alg.OperatorExpression> expr, creatorConfig);\n    case types.NAMED:\n      return transformNamed(<Alg.NamedExpression> expr, creatorConfig);\n    case types.EXISTENCE:\n      return transformExistence(<Alg.ExistenceExpression> expr);\n    case types.AGGREGATE:\n      return transformAggregate(<Alg.AggregateExpression> expr);\n    case types.WILDCARD:\n      return transformWildcard(<Alg.WildcardExpression> expr);\n    default: throw new Err.InvalidExpressionType(expr);\n  }\n}\n\n/**\n * Transforms an RDF term to the internal representation of a term,\n * assuming it is not a variable, which would be an expression (internally).\n *\n * @param term RDF term to transform into internal representation of a term\n */\nexport function transformRDFTermUnsafe(term: RDF.Term): E.Term {\n  return <E.Term> transformTerm({\n    term,\n    type: 'expression',\n    expressionType: 'term',\n  });\n}\n\nfunction transformTerm(term: Alg.TermExpression): E.Expression {\n  if (!term.term) {\n    throw new Err.InvalidExpression(term);\n  }\n\n  switch (term.term.termType) {\n    case 'Variable': return new E.Variable(RDFString.termToString(term.term));\n    case 'Literal': return transformLiteral(term.term);\n    case 'NamedNode': return new E.NamedNode(term.term.value);\n    case 'BlankNode': return new E.BlankNode(term.term.value);\n    default: throw new Err.InvalidTermType(term);\n  }\n}\n\nfunction transformWildcard(term: Alg.WildcardExpression): E.Expression {\n  if (!term.wildcard) {\n    throw new Err.InvalidExpression(term);\n  }\n\n  return new E.NamedNode(term.wildcard.value);\n}\n\n// TODO: Maybe do this with a map?\nexport function transformLiteral(lit: RDF.Literal): E.Literal<any> {\n  if (!lit.datatype) {\n    return lit.language ?\n      new E.LangStringLiteral(lit.value, lit.language) :\n      new E.StringLiteral(lit.value);\n  }\n\n  switch (lit.datatype.value) {\n    case null:\n    case undefined:\n    case '': {\n      return lit.language ?\n        new E.LangStringLiteral(lit.value, lit.language) :\n        new E.StringLiteral(lit.value);\n    }\n\n    case DT.XSD_STRING:\n      return new E.StringLiteral(lit.value);\n    case DT.RDF_LANG_STRING:\n      return new E.LangStringLiteral(lit.value, lit.language);\n\n    case DT.XSD_DATE_TIME:\n    case DT.XSD_DATE: {\n      const dateVal: Date = new Date(lit.value);\n      if (Number.isNaN(dateVal.getTime())) {\n        return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n      }\n      return new E.DateTimeLiteral(new Date(lit.value), lit.value);\n    }\n\n    case DT.XSD_BOOLEAN: {\n      if (lit.value !== 'true' && lit.value !== 'false' && lit.value !== '1' && lit.value !== '0') {\n        return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n      }\n      return new E.BooleanLiteral(lit.value === 'true' || lit.value === '1', lit.value);\n    }\n\n    case DT.XSD_INTEGER:\n    case DT.XSD_DECIMAL:\n    case DT.XSD_NEGATIVE_INTEGER:\n    case DT.XSD_NON_NEGATIVE_INTEGER:\n    case DT.XSD_NON_POSITIVE_INTEGER:\n    case DT.XSD_POSITIVE_INTEGER:\n    case DT.XSD_LONG:\n    case DT.XSD_SHORT:\n    case DT.XSD_BYTE:\n    case DT.XSD_UNSIGNED_LONG:\n    case DT.XSD_UNSIGNED_INT:\n    case DT.XSD_UNSIGNED_SHORT:\n    case DT.XSD_UNSIGNED_BYTE:\n    case DT.XSD_INT: {\n      const intVal: number = P.parseXSDDecimal(lit.value);\n      if (intVal === undefined) {\n        return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n      }\n      return new E.NumericLiteral(intVal, lit.datatype, lit.value);\n    }\n    case DT.XSD_FLOAT:\n    case DT.XSD_DOUBLE: {\n      const doubleVal: number = P.parseXSDFloat(lit.value);\n      if (doubleVal === undefined) {\n        return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n      }\n      return new E.NumericLiteral(doubleVal, lit.datatype, lit.value);\n    }\n    default: return new E.Literal<string>(lit.value, lit.datatype, lit.value);\n  }\n}\n\nfunction transformOperator(expr: Alg.OperatorExpression, creatorConfig: FunctionCreatorConfig):\nE.OperatorExpression | E.SpecialOperatorExpression {\n  if (C.SpecialOperators.has(expr.operator)) {\n    const specialOp = <C.SpecialOperator> expr.operator;\n    const specialArgs = expr.args.map(arg => transformAlgebra(arg, creatorConfig));\n    const specialFunc = specialFunctions[specialOp];\n    if (!specialFunc.checkArity(specialArgs)) {\n      throw new Err.InvalidArity(specialArgs, specialOp);\n    }\n    return new E.SpecialOperator(specialArgs, specialFunc.applyAsync, specialFunc.applySync);\n  }\n  if (!C.Operators.has(expr.operator)) {\n    throw new Err.UnknownOperator(expr.operator);\n  }\n  const regularOp = <C.RegularOperator> expr.operator;\n  const regularArgs = expr.args.map(arg => transformAlgebra(arg, creatorConfig));\n  const regularFunc = regularFunctions[regularOp];\n  if (!hasCorrectArity(regularArgs, regularFunc.arity)) {\n    throw new Err.InvalidArity(regularArgs, regularOp);\n  }\n  return new E.Operator(regularArgs, regularFunc.apply);\n}\n\nfunction wrapSyncFunction(func: SyncExtensionFunction, name: string): SimpleApplication {\n  return args => {\n    try {\n      const res = func(args.map(arg => arg.toRDF()));\n      return transformRDFTermUnsafe(res);\n    } catch (error: unknown) {\n      throw new ExtensionFunctionError(name, error);\n    }\n  };\n}\n\nfunction wrapAsyncFunction(func: AsyncExtensionFunction, name: string): AsyncExtensionApplication {\n  return async args => {\n    try {\n      const res = await func(args.map(arg => arg.toRDF()));\n      return transformRDFTermUnsafe(res);\n    } catch (error: unknown) {\n      throw new ExtensionFunctionError(name, error);\n    }\n  };\n}\n// TODO: Support passing functions to override default behaviour;\nfunction transformNamed(expr: Alg.NamedExpression, creatorConfig: FunctionCreatorConfig):\nE.NamedExpression | E.AsyncExtensionExpression | E.SyncExtensionExpression {\n  const funcName = expr.name.value;\n  const args = expr.args.map(arg => transformAlgebra(arg, creatorConfig));\n  if (C.NamedOperators.has(<C.NamedOperator> funcName)) {\n    // Return a basic named expression\n    const op = <C.NamedOperator> expr.name.value;\n    const namedFunc = namedFunctions[op];\n    return new E.Named(expr.name, args, namedFunc.apply);\n  }\n  if (creatorConfig.type === 'sync') {\n    // Expression might be extension function, check this for the sync\n    const syncExtensionFunc = creatorConfig.creator(expr.name);\n    if (syncExtensionFunc) {\n      const simpleAppl = wrapSyncFunction(syncExtensionFunc, expr.name.value);\n      return new E.SyncExtension(expr.name, args, simpleAppl);\n    }\n  } else {\n    // The expression might be an extension function, check this for the async case\n    const asyncExtensionFunc = creatorConfig.creator(expr.name);\n    if (asyncExtensionFunc) {\n      const asyncAppl = wrapAsyncFunction(asyncExtensionFunc, expr.name.value);\n      return new E.AsyncExtension(expr.name, args, asyncAppl);\n    }\n  }\n  throw new Err.UnknownNamedOperator(expr.name.value);\n}\n\nfunction hasCorrectArity(args: E.Expression[], arity: number | number[]): boolean {\n  // Infinity is used to represent var-args, so it's always correct.\n  if (arity === Number.POSITIVE_INFINITY) {\n    return true;\n  }\n\n  // If the function has overloaded arity, the actual arity needs to be present.\n  if (Array.isArray(arity)) {\n    return arity.includes(args.length);\n  }\n\n  return args.length === arity;\n}\n\nexport function transformAggregate(expr: Alg.AggregateExpression): E.Aggregate {\n  const name = expr.aggregator;\n  return new E.Aggregate(name, expr);\n}\n\nexport function transformExistence(expr: Alg.ExistenceExpression): E.Existence {\n  return new E.Existence(expr);\n}\n"]}