{"version":3,"file":"Types.js","sourceRoot":"","sources":["../../lib/Types.ts"],"names":[],"mappings":";;;AACA,wCAAwC;AACxC,yCAAgC;AAIhC;;;;;GAKG;AACH,wCAAwC;AACxC,SAAgB,QAAQ,CAAC,IAA8B;IACrD,OAAO,IAAA,eAAG,EAAC,IAAI,CAAC,CAAC;AACnB,CAAC;AAFD,4BAEC;AAMD,wBAAwB;AACxB,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;AAC/B,KAAK;AAEL,oBAAoB;AACpB,sFAAsF;AACtF,0FAA0F;AAC1F,4GAA4G","sourcesContent":["import type * as RDF from '@rdfjs/types';\n// eslint-disable-next-line no-redeclare\nimport { Map } from 'immutable';\n\nexport type Bindings = Map<string, RDF.Term>;\n\n/**\n * A convenience constructor for bindings based on a given hash.\n * @param {{[p: string]: RDF.Term}} hash A hash that maps variable names to terms.\n * @return {Bindings} The immutable bindings from the hash.\n * @constructor\n */\n// eslint-disable-next-line no-redeclare\nexport function Bindings(hash: Record<string, RDF.Term>): Bindings {\n  return Map(hash);\n}\n\nexport interface IExpressionEvaluator<ExpressionType, TermType> {\n  evaluate: (expr: ExpressionType, mapping: Bindings) => TermType;\n}\n\n// Export type Hooks = {\n//   existence?: ExistenceHook;\n//   aggregate?: AggregateHook;\n//   namedFunc?: NamedFuncHook;\n// };\n\n// // TODO: Document\n// export type NamedFuncHook = (expression: Alg.NamedExpression) => Promise<RDF.Term>;\n// export type AggregateHook = (expression: Alg.AggregateExpression) => Promise<RDF.Term>;\n// export type ExistenceHook = (expression: Alg.ExistenceExpression, mapping: Bindings) => Promise<boolean>;\n"]}