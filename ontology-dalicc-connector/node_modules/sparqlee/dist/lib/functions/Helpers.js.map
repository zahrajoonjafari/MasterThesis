{"version":3,"file":"Helpers.js","sourceRoot":"","sources":["../../../lib/functions/Helpers.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * These helpers provide a (albeit inflexible) DSL for writing function\n * definitions for the SPARQL functions.\n */\n\n// eslint-disable-next-line no-redeclare\nimport { List, Map } from 'immutable';\n\nimport * as E from '../expressions';\nimport type { SimpleApplication } from '../expressions';\nimport * as C from '../util/Consts';\nimport { TypeURL } from '../util/Consts';\nimport * as Err from '../util/Errors';\n\nimport type { ArgumentType, OverloadMap } from './Core';\nimport { promote } from './Core';\n\ntype Term = E.TermExpression;\n\nexport function declare(): Builder {\n  return new Builder();\n}\n\nexport class Builder {\n  private implementations: Impl[] = [];\n\n  public collect(): OverloadMap {\n    return map(this.implementations);\n  }\n\n  public add(impl: Impl): Builder {\n    this.implementations.push(impl);\n    return this;\n  }\n\n  public set(argTypes: ArgumentType[], func: E.SimpleApplication): Builder {\n    const types = List(argTypes);\n    return this.add(new Impl({ types, func }));\n  }\n\n  public copy({ from, to }: { from: ArgumentType[]; to: ArgumentType[] }): Builder {\n    const last = this.implementations.length - 1;\n    const _from = List(from);\n    for (let i = last; i >= 0; i--) {\n      const impl = this.implementations[i];\n      if (impl.types.equals(_from)) {\n        return this.set(to, impl.func);\n      }\n    }\n    throw new Err.UnexpectedError(\n      'Tried to copy implementation, but types not found',\n      { from, to },\n    );\n  }\n\n  public onUnary<T extends Term>(type: ArgumentType, op: (val: T) => Term): Builder {\n    return this.set([ type ], ([ val ]: [T]) => op(val));\n  }\n\n  public onUnaryTyped<T>(type: ArgumentType, op: (val: T) => Term): Builder {\n    return this.set([ type ], ([ val ]: [E.Literal<T>]) => op(val.typedValue));\n  }\n\n  public onBinary<L extends Term, R extends Term>(types: ArgumentType[], op: (left: L, right: R) => Term): Builder {\n    return this.set(types, ([ left, right ]: [L, R]) => op(left, right));\n  }\n\n  public onBinaryTyped<L, R>(types: ArgumentType[], op: (left: L, right: R) => Term): Builder {\n    return this.set(types, ([ left, right ]: [E.Literal<L>, E.Literal<R>]) => op(left.typedValue, right.typedValue));\n  }\n\n  public onTernaryTyped<A1, A2, A3>(types: ArgumentType[], op: (a1: A1, a2: A2, a3: A3) => Term): Builder {\n    return this.set(types, ([ a1, a2, a3 ]: [E.Literal<A1>, E.Literal<A2>, E.Literal<A3>]) =>\n      op(a1.typedValue, a2.typedValue, a3.typedValue));\n  }\n\n  public onTernary<\n    A1 extends Term,\n    A2 extends Term,\n    A3 extends Term\n  >(types: ArgumentType[], op: (a1: A1, a2: A2, a3: A3) => Term): Builder {\n    return this.set(types, ([ a1, a2, a3 ]: [A1, A2, A3]) => op(a1, a2, a3));\n  }\n\n  public onQuaternaryTyped<A1, A2, A3, A4>(types: ArgumentType[], op: (a1: A1, a2: A2, a3: A3, a4: A4) => Term):\n  Builder {\n    return this.set(types, ([ a1, a2, a3, a4 ]: [E.Literal<A1>, E.Literal<A2>, E.Literal<A3>, E.Literal<A4>]) =>\n      op(a1.typedValue, a2.typedValue, a3.typedValue, a4.typedValue));\n  }\n\n  public unimplemented(msg: string): Builder {\n    for (let arity = 0; arity <= 5; arity++) {\n      const types: ArgumentType[] = <ArgumentType[]> Array.from({ length: arity }).fill('term');\n      const func: SimpleApplication = (_args: Term[]) => {\n        throw new Err.UnimplementedError(msg);\n      };\n      this.set(types, func);\n    }\n    return this;\n  }\n\n  public onTerm1(op: (term: Term) => Term): Builder {\n    return this.set([ 'term' ], ([ term ]: [Term]) => op(term));\n  }\n\n  public onLiteral1<T>(op: (lit: E.Literal<T>) => Term): Builder {\n    return this.set([ 'literal' ], ([ term ]: [E.Literal<T>]) => op(term));\n  }\n\n  public onBoolean1(op: (lit: E.BooleanLiteral) => Term): Builder {\n    return this\n      .set([ 'boolean' ], ([ lit ]: [E.BooleanLiteral]) => op(lit));\n  }\n\n  public onBoolean1Typed(op: (lit: boolean) => Term): Builder {\n    return this\n      .set([ 'boolean' ], ([ lit ]: [E.BooleanLiteral]) => op(lit.typedValue));\n  }\n\n  public onString1(op: (lit: E.Literal<string>) => Term): Builder {\n    return this\n      .set([ 'string' ], ([ lit ]: [E.Literal<string>]) => op(lit));\n  }\n\n  public onString1Typed(op: (lit: string) => Term): Builder {\n    return this\n      .set([ 'string' ], ([ lit ]: [E.Literal<string>]) => op(lit.typedValue));\n  }\n\n  public onLangString1(op: (lit: E.LangStringLiteral) => Term): Builder {\n    return this\n      .set([ 'langString' ], ([ lit ]: [E.LangStringLiteral]) => op(lit));\n  }\n\n  public onStringly1(op: (lit: E.Literal<string>) => Term): Builder {\n    return this\n      .set([ 'string' ], ([ lit ]: [E.Literal<string>]) => op(lit))\n      .set([ 'langString' ], ([ lit ]: [E.Literal<string>]) => op(lit));\n  }\n\n  public onStringly1Typed(op: (lit: string) => Term): Builder {\n    return this\n      .set([ 'string' ], ([ lit ]: [E.Literal<string>]) => op(lit.typedValue))\n      .set([ 'langString' ], ([ lit ]: [E.Literal<string>]) => op(lit.typedValue));\n  }\n\n  public onNumeric1(op: (val: E.NumericLiteral) => Term): Builder {\n    return this\n      .set([ 'integer' ], ([ val ]: [E.NumericLiteral]) => op(val))\n      .set([ 'decimal' ], ([ val ]: [E.NumericLiteral]) => op(val))\n      .set([ 'float' ], ([ val ]: [E.NumericLiteral]) => op(val))\n      .set([ 'double' ], ([ val ]: [E.NumericLiteral]) => op(val))\n      .invalidLexicalForm([ 'nonlexical' ], 1);\n  }\n\n  public onDateTime1(op: (date: E.DateTimeLiteral) => Term): Builder {\n    return this\n      .set([ 'date' ], ([ val ]: [E.DateTimeLiteral]) => op(val))\n      .invalidLexicalForm([ 'nonlexical' ], 1);\n  }\n\n  /**\n   * Arithmetic operators take 2 numeric arguments, and return a single numerical\n   * value. The type of the return value is heavily dependant on the types of the\n   * input arguments. In JS everything is a double, but in SPARQL it is not.\n   *\n   * {@link https://www.w3.org/TR/sparql11-query/#OperatorMapping}\n   * {@link https://www.w3.org/TR/xpath-functions/#op.numeric}\n   *\n   * @param op the (simple) binary mathematical operator that\n   */\n  public arithmetic(op: (left: number, right: number) => number): Builder {\n    return this.numeric(([ left, right ]: E.NumericLiteral[]) => {\n      const promotionType = promote(left.type, right.type);\n      const resultType = C.decategorize(promotionType);\n      return number(op(left.typedValue, right.typedValue), resultType);\n    });\n  }\n\n  public numberTest(test: (left: number, right: number) => boolean): Builder {\n    return this.numeric(([ left, right ]: E.NumericLiteral[]) => {\n      const result = test(left.typedValue, right.typedValue);\n      return bool(result);\n    });\n  }\n\n  public stringTest(test: (left: string, right: string) => boolean): Builder {\n    return this\n      .set(\n        [ 'string', 'string' ],\n        ([ left, right ]: E.StringLiteral[]) => {\n          const result = test(left.typedValue, right.typedValue);\n          return bool(result);\n        },\n      )\n      .invalidLexicalForm([ 'nonlexical', 'string' ], 1)\n      .invalidLexicalForm([ 'string', 'nonlexical' ], 2);\n  }\n\n  public booleanTest(test: (left: boolean, right: boolean) => boolean): Builder {\n    return this\n      .set(\n        [ 'boolean', 'boolean' ],\n        ([ left, right ]: E.BooleanLiteral[]) => {\n          const result = test(left.typedValue, right.typedValue);\n          return bool(result);\n        },\n      )\n      .invalidLexicalForm([ 'nonlexical', 'boolean' ], 1)\n      .invalidLexicalForm([ 'boolean', 'nonlexical' ], 2);\n  }\n\n  public dateTimeTest(test: (left: Date, right: Date) => boolean): Builder {\n    return this\n      .set(\n        [ 'date', 'date' ],\n        ([ left, right ]: E.DateTimeLiteral[]) => {\n          const result = test(left.typedValue, right.typedValue);\n          return bool(result);\n        },\n      )\n      .invalidLexicalForm([ 'nonlexical', 'date' ], 1)\n      .invalidLexicalForm([ 'date', 'nonlexical' ], 2);\n  }\n\n  public numeric(op: E.SimpleApplication): Builder {\n    return this\n      .set([ 'integer', 'integer' ], op)\n      .set([ 'integer', 'decimal' ], op)\n      .set([ 'integer', 'float' ], op)\n      .set([ 'integer', 'double' ], op)\n      .invalidLexicalForm([ 'integer', 'nonlexical' ], 2)\n\n      .set([ 'decimal', 'integer' ], op)\n      .set([ 'decimal', 'decimal' ], op)\n      .set([ 'decimal', 'float' ], op)\n      .set([ 'decimal', 'double' ], op)\n      .invalidLexicalForm([ 'decimal', 'nonlexical' ], 2)\n\n      .set([ 'float', 'integer' ], op)\n      .set([ 'float', 'decimal' ], op)\n      .set([ 'float', 'float' ], op)\n      .set([ 'float', 'double' ], op)\n      .invalidLexicalForm([ 'float', 'nonlexical' ], 2)\n\n      .set([ 'double', 'integer' ], op)\n      .set([ 'double', 'decimal' ], op)\n      .set([ 'double', 'float' ], op)\n      .set([ 'double', 'double' ], op)\n      .invalidLexicalForm([ 'double', 'nonlexical' ], 2)\n\n      .invalidLexicalForm([ 'nonlexical', 'integer' ], 1)\n      .invalidLexicalForm([ 'nonlexical', 'decimal' ], 1)\n      .invalidLexicalForm([ 'nonlexical', 'float' ], 1)\n      .invalidLexicalForm([ 'nonlexical', 'double' ], 1);\n  }\n\n  public invalidLexicalForm(types: ArgumentType[], index: number): Builder {\n    return this.set(types, (args: Term[]): E.TermExpression => {\n      throw new Err.InvalidLexicalForm(args[index - 1].toRDF());\n    });\n  }\n\n  private chain(impls: Impl[]): Builder {\n    this.implementations = [ ...this.implementations, ...impls ];\n    return this;\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Type Safety Helpers\n// ----------------------------------------------------------------------------\n\n/**\n * Immutable.js type definitions are pretty unsafe, and this is typo-prone work.\n * These helpers allow use to create OverloadMaps with more type-safety.\n * One entry in the OverloadMap is described by the record Impl;\n *\n * A list of Impl's then gets constructed into an Immutable.js Map.\n *\n * See:\n * https://medium.com/@alexxgent/enforcing-types-with-immutablejs-and-typescript-6ab980819b6a\n */\n\nexport interface IImplType {\n  types: List<ArgumentType>;\n  func: E.SimpleApplication;\n}\n\nconst implDefaults: IImplType = {\n  types: List(),\n  func() {\n    const msg = 'Implementation not set yet declared as implemented';\n    throw new Err.UnexpectedError(msg);\n  },\n};\n\nexport class Impl implements IImplType {\n  public types: List<ArgumentType>;\n  public func: E.SimpleApplication;\n\n  public constructor(params?: IImplType) {\n    this.init(params || implDefaults);\n  }\n\n  private init(params: IImplType): void {\n    this.types = params.types;\n    this.func = params.func;\n  }\n}\n\nexport function map(implementations: Impl[]): OverloadMap {\n  const typeImplPair = implementations.map(i => [ i.types, i.func ]);\n  return Map<List<ArgumentType>, E.SimpleApplication>(typeImplPair);\n}\n\n// ----------------------------------------------------------------------------\n// Literal Construction helpers\n// ----------------------------------------------------------------------------\n\nexport function bool(val: boolean): E.BooleanLiteral {\n  return new E.BooleanLiteral(val);\n}\n\nexport function number(num: number, dt?: C.TypeURL): E.NumericLiteral {\n  return new E.NumericLiteral(num, C.make(dt || TypeURL.XSD_FLOAT), undefined);\n}\n\nexport function numberFromString(str: string, dt?: C.TypeURL): E.NumericLiteral {\n  const num = Number(str);\n  return new E.NumericLiteral(num, C.make(dt || TypeURL.XSD_FLOAT), undefined);\n}\n\nexport function string(str: string): E.StringLiteral {\n  return new E.StringLiteral(str);\n}\n\nexport function langString(str: string, lang: string): E.LangStringLiteral {\n  return new E.LangStringLiteral(str, lang);\n}\n\nexport function dateTime(date: Date, str: string): E.DateTimeLiteral {\n  return new E.DateTimeLiteral(date, str);\n}\n\n// ----------------------------------------------------------------------------\n// Util\n// ----------------------------------------------------------------------------\n\nexport function typeCheckLit<T>(\n  term: E.TermExpression,\n  allowed: ArgumentType[],\n  args: E.Expression[],\n  op: C.Operator,\n): E.Literal<T> {\n  if (term.termType !== 'literal') {\n    throw new Err.InvalidArgumentTypes(args, op);\n  }\n\n  const lit = <E.Literal<any>> term;\n\n  if (!allowed.includes(lit.type)) {\n    throw new Err.InvalidArgumentTypes(args, op);\n  }\n\n  return lit;\n}\n"]}