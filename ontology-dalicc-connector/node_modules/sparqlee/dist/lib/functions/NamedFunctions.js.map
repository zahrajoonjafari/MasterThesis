{"version":3,"file":"NamedFunctions.js","sourceRoot":"","sources":["../../../lib/functions/NamedFunctions.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as E from '../expressions';\nimport type * as C from '../util/Consts';\nimport { TypeURL } from '../util/Consts';\nimport * as Err from '../util/Errors';\n\nimport {\n  parseXSDDecimal,\n  parseXSDFloat,\n  parseXSDInteger,\n} from '../util/Parsing';\n\nimport type { OverloadMap } from './Core';\nimport { bool, dateTime, declare, number, string } from './Helpers';\n\ntype Term = E.TermExpression;\n\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// Begin definitions.\n\n// ----------------------------------------------------------------------------\n// XPath Constructor functions\n// https://www.w3.org/TR/sparql11-query/#\n// https://www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive\n// ----------------------------------------------------------------------------\n\nconst xsdToString = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1((val: E.NumericLiteral) => string(number(val.typedValue).str()))\n    .onBoolean1Typed(val => string(bool(val).str()))\n    .onTerm1((val: E.StringLiteral) => string(val.str()))\n    .collect(),\n};\n\nconst xsdToFloat = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1((val: E.NumericLiteral) => number(val.typedValue))\n    .onBoolean1Typed(val => number(val ? 1 : 0))\n    .onUnary('string', (val: E.StringLiteral) => {\n      const result = parseXSDFloat(val.str());\n      if (result === undefined) {\n        throw new Err.CastError(val, TypeURL.XSD_FLOAT);\n      }\n      return number(result);\n    })\n    .copy({ from: [ 'string' ], to: [ 'nonlexical' ]})\n    .collect(),\n};\n\nconst xsdToDouble = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1((val: E.NumericLiteral) => number(val.typedValue, TypeURL.XSD_DOUBLE))\n    .onBoolean1Typed(val => number(val ? 1 : 0, TypeURL.XSD_DOUBLE))\n    .onUnary('string', (val: E.Term) => {\n      const result = parseXSDFloat(val.str());\n      if (result === undefined) {\n        throw new Err.CastError(val, TypeURL.XSD_DOUBLE);\n      }\n      return number(result, TypeURL.XSD_DOUBLE);\n    })\n    .copy({ from: [ 'string' ], to: [ 'nonlexical' ]})\n    .collect(),\n};\n\nconst xsdToDecimal = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1((val: E.Term) => {\n      const result = parseXSDDecimal(val.str());\n      if (result === undefined) {\n        throw new Err.CastError(val, TypeURL.XSD_DECIMAL);\n      }\n      return number(result, TypeURL.XSD_DECIMAL);\n    })\n    .onString1((val: E.Term) => {\n      const str = val.str();\n      const result = /^([+-])?(\\d+(\\.\\d+)?)$/u.test(str) ? parseXSDDecimal(str) : undefined;\n      if (result === undefined) {\n        throw new Err.CastError(val, TypeURL.XSD_DECIMAL);\n      }\n      return number(result, TypeURL.XSD_DECIMAL);\n    })\n    .copy({ from: [ 'string' ], to: [ 'nonlexical' ]})\n    .onBoolean1Typed(val => number(val ? 1 : 0, TypeURL.XSD_DECIMAL))\n    .collect(),\n};\n\nconst xsdToInteger = {\n  arity: 1,\n  overloads: declare()\n    .onBoolean1Typed(val => number(val ? 1 : 0, TypeURL.XSD_INTEGER))\n    .onNumeric1((val: E.Term) => {\n      const result = parseXSDInteger(val.str());\n      if (result === undefined) {\n        throw new Err.CastError(val, TypeURL.XSD_INTEGER);\n      }\n      return number(result, TypeURL.XSD_INTEGER);\n    })\n    .onString1((val: E.Term) => {\n      const str = val.str();\n      const result = /^\\d+$/u.test(str) ? parseXSDInteger(str) : undefined;\n      if (result === undefined) {\n        throw new Err.CastError(val, TypeURL.XSD_INTEGER);\n      }\n      return number(result, TypeURL.XSD_INTEGER);\n    })\n    .copy({ from: [ 'integer' ], to: [ 'nonlexical' ]})\n    .collect(),\n};\n\nconst xsdToDatetime = {\n  arity: 1,\n  overloads: declare()\n    .onUnary('date', (val: E.DateTimeLiteral) => val)\n    .onUnary('string', (val: Term) => {\n      const date = new Date(val.str());\n      if (Number.isNaN(date.getTime())) {\n        throw new Err.CastError(val, TypeURL.XSD_DATE_TIME);\n      }\n      return dateTime(date, val.str());\n    })\n    .copy({ from: [ 'string' ], to: [ 'nonlexical' ]})\n    .collect(),\n};\n\nconst xsdToBoolean = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1((val: E.NumericLiteral) => bool(val.coerceEBV()))\n    .onUnary('boolean', (val: Term) => bool(val.coerceEBV()))\n    .onUnary('string', (val: Term) => {\n      switch (val.str()) {\n        case 'true':\n          return bool(true);\n        case 'false':\n          return bool(false);\n        case '1':\n          return bool(true);\n        case '0':\n          return bool(false);\n        default:\n          throw new Err.CastError(val, TypeURL.XSD_BOOLEAN);\n      }\n    })\n    .copy({ from: [ 'string' ], to: [ 'nonlexical' ]})\n    .collect(),\n};\n\n// End definitions.\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\nexport const namedDefinitions: Record<C.NamedOperator, IDefinition> = {\n  // --------------------------------------------------------------------------\n  // XPath Constructor functions\n  // https://www.w3.org/TR/sparql11-query/#FunctionMapping\n  // --------------------------------------------------------------------------\n  [TypeURL.XSD_STRING]: xsdToString,\n  [TypeURL.XSD_FLOAT]: xsdToFloat,\n  [TypeURL.XSD_DOUBLE]: xsdToDouble,\n  [TypeURL.XSD_DECIMAL]: xsdToDecimal,\n  [TypeURL.XSD_INTEGER]: xsdToInteger,\n  [TypeURL.XSD_DATE_TIME]: xsdToDatetime,\n  [TypeURL.XSD_DATE]: xsdToDatetime,\n  [TypeURL.XSD_BOOLEAN]: xsdToBoolean,\n};\n\n// ----------------------------------------------------------------------------\n// The definitions and functionality for all operators\n// ----------------------------------------------------------------------------\n\nexport interface IDefinition {\n  arity: number | number[];\n  overloads: OverloadMap;\n}\n"]}