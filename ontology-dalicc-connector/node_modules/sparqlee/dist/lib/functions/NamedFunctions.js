"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.namedDefinitions = void 0;
const Consts_1 = require("../util/Consts");
const Err = require("../util/Errors");
const Parsing_1 = require("../util/Parsing");
const Helpers_1 = require("./Helpers");
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// Begin definitions.
// ----------------------------------------------------------------------------
// XPath Constructor functions
// https://www.w3.org/TR/sparql11-query/#
// https://www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive
// ----------------------------------------------------------------------------
const xsdToString = {
    arity: 1,
    overloads: (0, Helpers_1.declare)()
        .onNumeric1((val) => (0, Helpers_1.string)((0, Helpers_1.number)(val.typedValue).str()))
        .onBoolean1Typed(val => (0, Helpers_1.string)((0, Helpers_1.bool)(val).str()))
        .onTerm1((val) => (0, Helpers_1.string)(val.str()))
        .collect(),
};
const xsdToFloat = {
    arity: 1,
    overloads: (0, Helpers_1.declare)()
        .onNumeric1((val) => (0, Helpers_1.number)(val.typedValue))
        .onBoolean1Typed(val => (0, Helpers_1.number)(val ? 1 : 0))
        .onUnary('string', (val) => {
        const result = (0, Parsing_1.parseXSDFloat)(val.str());
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_FLOAT);
        }
        return (0, Helpers_1.number)(result);
    })
        .copy({ from: ['string'], to: ['nonlexical'] })
        .collect(),
};
const xsdToDouble = {
    arity: 1,
    overloads: (0, Helpers_1.declare)()
        .onNumeric1((val) => (0, Helpers_1.number)(val.typedValue, Consts_1.TypeURL.XSD_DOUBLE))
        .onBoolean1Typed(val => (0, Helpers_1.number)(val ? 1 : 0, Consts_1.TypeURL.XSD_DOUBLE))
        .onUnary('string', (val) => {
        const result = (0, Parsing_1.parseXSDFloat)(val.str());
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_DOUBLE);
        }
        return (0, Helpers_1.number)(result, Consts_1.TypeURL.XSD_DOUBLE);
    })
        .copy({ from: ['string'], to: ['nonlexical'] })
        .collect(),
};
const xsdToDecimal = {
    arity: 1,
    overloads: (0, Helpers_1.declare)()
        .onNumeric1((val) => {
        const result = (0, Parsing_1.parseXSDDecimal)(val.str());
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_DECIMAL);
        }
        return (0, Helpers_1.number)(result, Consts_1.TypeURL.XSD_DECIMAL);
    })
        .onString1((val) => {
        const str = val.str();
        const result = /^([+-])?(\d+(\.\d+)?)$/u.test(str) ? (0, Parsing_1.parseXSDDecimal)(str) : undefined;
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_DECIMAL);
        }
        return (0, Helpers_1.number)(result, Consts_1.TypeURL.XSD_DECIMAL);
    })
        .copy({ from: ['string'], to: ['nonlexical'] })
        .onBoolean1Typed(val => (0, Helpers_1.number)(val ? 1 : 0, Consts_1.TypeURL.XSD_DECIMAL))
        .collect(),
};
const xsdToInteger = {
    arity: 1,
    overloads: (0, Helpers_1.declare)()
        .onBoolean1Typed(val => (0, Helpers_1.number)(val ? 1 : 0, Consts_1.TypeURL.XSD_INTEGER))
        .onNumeric1((val) => {
        const result = (0, Parsing_1.parseXSDInteger)(val.str());
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_INTEGER);
        }
        return (0, Helpers_1.number)(result, Consts_1.TypeURL.XSD_INTEGER);
    })
        .onString1((val) => {
        const str = val.str();
        const result = /^\d+$/u.test(str) ? (0, Parsing_1.parseXSDInteger)(str) : undefined;
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_INTEGER);
        }
        return (0, Helpers_1.number)(result, Consts_1.TypeURL.XSD_INTEGER);
    })
        .copy({ from: ['integer'], to: ['nonlexical'] })
        .collect(),
};
const xsdToDatetime = {
    arity: 1,
    overloads: (0, Helpers_1.declare)()
        .onUnary('date', (val) => val)
        .onUnary('string', (val) => {
        const date = new Date(val.str());
        if (Number.isNaN(date.getTime())) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_DATE_TIME);
        }
        return (0, Helpers_1.dateTime)(date, val.str());
    })
        .copy({ from: ['string'], to: ['nonlexical'] })
        .collect(),
};
const xsdToBoolean = {
    arity: 1,
    overloads: (0, Helpers_1.declare)()
        .onNumeric1((val) => (0, Helpers_1.bool)(val.coerceEBV()))
        .onUnary('boolean', (val) => (0, Helpers_1.bool)(val.coerceEBV()))
        .onUnary('string', (val) => {
        switch (val.str()) {
            case 'true':
                return (0, Helpers_1.bool)(true);
            case 'false':
                return (0, Helpers_1.bool)(false);
            case '1':
                return (0, Helpers_1.bool)(true);
            case '0':
                return (0, Helpers_1.bool)(false);
            default:
                throw new Err.CastError(val, Consts_1.TypeURL.XSD_BOOLEAN);
        }
    })
        .copy({ from: ['string'], to: ['nonlexical'] })
        .collect(),
};
// End definitions.
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
exports.namedDefinitions = {
    // --------------------------------------------------------------------------
    // XPath Constructor functions
    // https://www.w3.org/TR/sparql11-query/#FunctionMapping
    // --------------------------------------------------------------------------
    [Consts_1.TypeURL.XSD_STRING]: xsdToString,
    [Consts_1.TypeURL.XSD_FLOAT]: xsdToFloat,
    [Consts_1.TypeURL.XSD_DOUBLE]: xsdToDouble,
    [Consts_1.TypeURL.XSD_DECIMAL]: xsdToDecimal,
    [Consts_1.TypeURL.XSD_INTEGER]: xsdToInteger,
    [Consts_1.TypeURL.XSD_DATE_TIME]: xsdToDatetime,
    [Consts_1.TypeURL.XSD_DATE]: xsdToDatetime,
    [Consts_1.TypeURL.XSD_BOOLEAN]: xsdToBoolean,
};
//# sourceMappingURL=NamedFunctions.js.map