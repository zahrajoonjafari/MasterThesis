{"version":3,"file":"SpecialFunctions.js","sourceRoot":"","sources":["../../../lib/functions/SpecialFunctions.ts"],"names":[],"mappings":"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","sourcesContent":["import { resolve as resolveRelativeIri } from 'relative-to-absolute-iri';\nimport * as uuid from 'uuid';\n\nimport * as E from '../expressions';\nimport type { Bindings } from '../Types';\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\n\nimport { bool, langString, string, typeCheckLit } from './Helpers';\nimport { regularFunctions, specialFunctions } from '.';\n\ntype Term = E.TermExpression;\ntype PTerm = Promise<E.TermExpression>;\n\n// ----------------------------------------------------------------------------\n// Functional forms\n// ----------------------------------------------------------------------------\n\nfunction _bound({ args, mapping }: { args: E.Expression[]; mapping: Bindings }): E.BooleanLiteral {\n  const variable = <E.VariableExpression> args[0];\n  if (variable.expressionType !== E.ExpressionType.Variable) {\n    throw new Err.InvalidArgumentTypes(args, C.SpecialOperator.BOUND);\n  }\n  const val = mapping.has(variable.name) && !!mapping.get(variable.name);\n  return bool(val);\n}\n\n// BOUND ----------------------------------------------------------------------\nconst bound = {\n  arity: 1,\n  async applyAsync({ args, mapping }: E.EvalContextAsync): PTerm {\n    return _bound({ args, mapping });\n  },\n  applySync({ args, mapping }: E.EvalContextSync): Term {\n    return _bound({ args, mapping });\n  },\n};\n\n// IF -------------------------------------------------------------------------\nconst ifSPARQL = {\n  arity: 3,\n  async applyAsync({ args, mapping, evaluate }: E.EvalContextAsync): PTerm {\n    const valFirst = await evaluate(args[0], mapping);\n    const ebv = valFirst.coerceEBV();\n    return ebv ?\n      evaluate(args[1], mapping) :\n      evaluate(args[2], mapping);\n  },\n  applySync({ args, mapping, evaluate }: E.EvalContextSync): Term {\n    const valFirst = evaluate(args[0], mapping);\n    const ebv = valFirst.coerceEBV();\n    return ebv ?\n      evaluate(args[1], mapping) :\n      evaluate(args[2], mapping);\n  },\n};\n\n// COALESCE -------------------------------------------------------------------\nconst coalesce = {\n  arity: Number.POSITIVE_INFINITY,\n  async applyAsync({ args, mapping, evaluate }: E.EvalContextAsync): PTerm {\n    const errors: Error[] = [];\n    for (const expr of args) {\n      try {\n        return await evaluate(expr, mapping);\n      } catch (error: unknown) {\n        errors.push(<Error> error);\n      }\n    }\n    throw new Err.CoalesceError(errors);\n  },\n  applySync({ args, mapping, evaluate }: E.EvalContextSync): Term {\n    const errors: Error[] = [];\n    for (const expr of args) {\n      try {\n        return evaluate(expr, mapping);\n      } catch (error: unknown) {\n        errors.push(<Error> error);\n      }\n    }\n    throw new Err.CoalesceError(errors);\n  },\n};\n\n// Logical-or (||) ------------------------------------------------------------\n// https://www.w3.org/TR/sparql11-query/#func-logical-or\nconst logicalOr = {\n  arity: 2,\n  async applyAsync({ args, mapping, evaluate }: E.EvalContextAsync): PTerm {\n    const [ leftExpr, rightExpr ] = args;\n    try {\n      const leftTerm = await evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (left) {\n        return bool(true);\n      }\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (error: unknown) {\n      const rightErrorTerm = await evaluate(rightExpr, mapping);\n      const rightError = rightErrorTerm.coerceEBV();\n      if (!rightError) {\n        throw error;\n      }\n      return bool(true);\n    }\n  },\n  applySync({ args, mapping, evaluate }: E.EvalContextSync): Term {\n    const [ leftExpr, rightExpr ] = args;\n    try {\n      const leftTerm = evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (left) {\n        return bool(true);\n      }\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (error: unknown) {\n      const rightErrorTerm = evaluate(rightExpr, mapping);\n      const rightError = rightErrorTerm.coerceEBV();\n      if (!rightError) {\n        throw error;\n      }\n      return bool(true);\n    }\n  },\n};\n\n// Logical-and (&&) -----------------------------------------------------------\n// https://www.w3.org/TR/sparql11-query/#func-logical-and\nconst logicalAnd = {\n  arity: 2,\n  async applyAsync({ args, mapping, evaluate }: E.EvalContextAsync): PTerm {\n    const [ leftExpr, rightExpr ] = args;\n    try {\n      const leftTerm = await evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (!left) {\n        return bool(false);\n      }\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (error: unknown) {\n      const rightErrorTerm = await evaluate(rightExpr, mapping);\n      const rightError = rightErrorTerm.coerceEBV();\n      if (rightError) {\n        throw error;\n      }\n      return bool(false);\n    }\n  },\n  applySync({ args, mapping, evaluate }: E.EvalContextSync): Term {\n    const [ leftExpr, rightExpr ] = args;\n    try {\n      const leftTerm = evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (!left) {\n        return bool(false);\n      }\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (error: unknown) {\n      const rightErrorTerm = evaluate(rightExpr, mapping);\n      const rightError = rightErrorTerm.coerceEBV();\n      if (rightError) {\n        throw error;\n      }\n      return bool(false);\n    }\n  },\n};\n\n// SameTerm -------------------------------------------------------------------\nconst sameTerm = {\n  arity: 2,\n  async applyAsync({ args, mapping, evaluate }: E.EvalContextAsync): PTerm {\n    const [ leftExpr, rightExpr ] = args.map(arg => evaluate(arg, mapping));\n    const left = await leftExpr;\n    const right = await rightExpr;\n    return bool(left.toRDF().equals(right.toRDF()));\n  },\n  applySync({ args, mapping, evaluate }: E.EvalContextSync): Term {\n    const [ left, right ] = args.map(arg => evaluate(arg, mapping));\n    return bool(left.toRDF().equals(right.toRDF()));\n  },\n};\n\n// IN -------------------------------------------------------------------------\nconst inSPARQL = {\n  arity: Number.POSITIVE_INFINITY,\n  checkArity(args: E.Expression[]) {\n    return args.length > 0;\n  },\n  async applyAsync({ args, mapping, evaluate, context }: E.EvalContextAsync): PTerm {\n    const [ leftExpr, ...remaining ] = args;\n    const left = await evaluate(leftExpr, mapping);\n    return inRecursiveAsync(left, { args: remaining, mapping, evaluate, context }, []);\n  },\n  applySync({ args, mapping, evaluate, context }: E.EvalContextSync): Term {\n    const [ leftExpr, ...remaining ] = args;\n    const left = evaluate(leftExpr, mapping);\n    return inRecursiveSync(left, { args: remaining, mapping, evaluate, context }, []);\n  },\n};\n\nasync function inRecursiveAsync(\n  needle: Term,\n  { args, mapping, evaluate, context }: E.EvalContextAsync,\n  results: (Error | false)[],\n): PTerm {\n  if (args.length === 0) {\n    const noErrors = results.every(val => !val);\n    return noErrors ? bool(false) : Promise.reject(new Err.InError(results));\n  }\n\n  try {\n    const next = await evaluate(args.shift(), mapping);\n    const isEqual = regularFunctions[C.RegularOperator.EQUAL];\n    if ((<E.BooleanLiteral> isEqual.apply([ needle, next ])).typedValue) {\n      return bool(true);\n    }\n    return inRecursiveAsync(needle, { args, mapping, evaluate, context }, [ ...results, false ]);\n  } catch (error: unknown) {\n    return inRecursiveAsync(needle, { args, mapping, evaluate, context }, [ ...results, <Error> error ]);\n  }\n}\n\nfunction inRecursiveSync(\n  needle: Term,\n  { args, mapping, evaluate, context }: E.EvalContextSync,\n  results: (Error | false)[],\n): Term {\n  if (args.length === 0) {\n    const noErrors = results.every(val => !val);\n    if (noErrors) {\n      return bool(false);\n    }\n    throw new Err.InError(results);\n  }\n\n  try {\n    const next = evaluate(args.shift(), mapping);\n    const isEqual = regularFunctions[C.RegularOperator.EQUAL];\n    if ((<E.BooleanLiteral> isEqual.apply([ needle, next ])).typedValue) {\n      return bool(true);\n    }\n    return inRecursiveSync(needle, { args, mapping, evaluate, context }, [ ...results, false ]);\n  } catch (error: unknown) {\n    return inRecursiveSync(needle, { args, mapping, evaluate, context }, [ ...results, <Error> error ]);\n  }\n}\n\n// NOT IN ---------------------------------------------------------------------\nconst notInSPARQL = {\n  arity: Number.POSITIVE_INFINITY,\n  checkArity(args: E.Expression[]) {\n    return args.length > 0;\n  },\n  async applyAsync(context: E.EvalContextAsync): PTerm {\n    const _in = specialFunctions[C.SpecialOperator.IN];\n    const isIn = await _in.applyAsync(context);\n    return bool(!(<E.BooleanLiteral> isIn).typedValue);\n  },\n  applySync(context: E.EvalContextSync): Term {\n    const _in = specialFunctions[C.SpecialOperator.IN];\n    const isIn = _in.applySync(context);\n    return bool(!(<E.BooleanLiteral> isIn).typedValue);\n  },\n};\n\n// ----------------------------------------------------------------------------\n// Annoying functions\n// ----------------------------------------------------------------------------\n\n// CONCAT\nconst concat = {\n  arity: Number.POSITIVE_INFINITY,\n  async applyAsync({ args, evaluate, mapping }: E.EvalContextAsync): PTerm {\n    const pLits = args\n      .map(async expr => evaluate(expr, mapping))\n      .map(async pTerm =>\n        typeCheckLit<string>(await pTerm, [ 'string', 'langString' ], args, C.SpecialOperator.CONCAT));\n    const lits = await Promise.all(pLits);\n    const strings = lits.map(lit => lit.typedValue);\n    const joined = strings.join('');\n    const lang = langAllEqual(lits) ? lits[0].language : undefined;\n    return lang ? langString(joined, lang) : string(joined);\n  },\n\n  applySync({ args, evaluate, mapping }: E.EvalContextSync): Term {\n    const lits = args\n      .map(expr => evaluate(expr, mapping))\n      .map(pTerm => typeCheckLit<string>(pTerm, [ 'string', 'langString' ], args, C.SpecialOperator.CONCAT));\n    const strings = lits.map(lit => lit.typedValue);\n    const joined = strings.join('');\n    const lang = langAllEqual(lits) ? lits[0].language : undefined;\n    return lang ? langString(joined, lang) : string(joined);\n  },\n};\n\nfunction langAllEqual(lits: E.Literal<string>[]): boolean {\n  return lits.length > 0 && lits.every(lit => lit.language === lits[0].language);\n}\n\n// ----------------------------------------------------------------------------\n// Context dependant functions\n// ----------------------------------------------------------------------------\n\nconst now = {\n  arity: 0,\n  async applyAsync({ context }: E.EvalContextAsync): PTerm {\n    return new E.DateTimeLiteral(context.now, context.now.toISOString());\n  },\n  applySync({ context }: E.EvalContextSync): Term {\n    return new E.DateTimeLiteral(context.now, context.now.toISOString());\n  },\n};\n\n// https://www.w3.org/TR/sparql11-query/#func-iri\nconst IRI = {\n  arity: 1,\n  async applyAsync({ args, evaluate, mapping, context }: E.EvalContextAsync): PTerm {\n    const input = await evaluate(args[0], mapping);\n    return IRI_(input, context.baseIRI, args);\n  },\n  applySync({ args, evaluate, mapping, context }: E.EvalContextSync): Term {\n    const input = evaluate(args[0], mapping);\n    return IRI_(input, context.baseIRI, args);\n  },\n};\n\nfunction IRI_(input: Term, baseIRI: string | undefined, args: E.Expression[]): Term {\n  const lit = input.termType !== 'namedNode' ?\n    typeCheckLit<string>(input, [ 'string' ], args, C.SpecialOperator.IRI) :\n    <E.NamedNode> input;\n\n  const iri = resolveRelativeIri(lit.str(), baseIRI || '');\n  return new E.NamedNode(iri);\n}\n\n// https://www.w3.org/TR/sparql11-query/#func-bnode\n// id has to be distinct over all id's in dataset\nconst BNODE = {\n  arity: Number.POSITIVE_INFINITY,\n  checkArity(args: E.Expression[]) {\n    return args.length === 0 || args.length === 1;\n  },\n  async applyAsync({ args, evaluate, mapping, context }: E.EvalContextAsync): PTerm {\n    const input = args.length === 1 ?\n      await evaluate(args[0], mapping) :\n      undefined;\n\n    const strInput = input ?\n      typeCheckLit(input, [ 'string' ], args, C.SpecialOperator.BNODE).str() :\n      undefined;\n\n    if (context.bnode) {\n      const bnode = await context.bnode(strInput);\n      return new E.BlankNode(bnode);\n    }\n\n    return BNODE_(strInput);\n  },\n  applySync({ args, evaluate, mapping, context }: E.EvalContextSync): Term {\n    const input = args.length === 1 ?\n      evaluate(args[0], mapping) :\n      undefined;\n\n    const strInput = input ?\n      typeCheckLit(input, [ 'string' ], args, C.SpecialOperator.BNODE).str() :\n      undefined;\n\n    if (context.bnode) {\n      const bnode = context.bnode(strInput);\n      return new E.BlankNode(bnode);\n    }\n\n    return BNODE_(strInput);\n  },\n};\n\nfunction BNODE_(input?: string): E.BlankNode {\n  return new E.BlankNode(input || uuid.v4());\n}\n\n// ----------------------------------------------------------------------------\n// Wrap these declarations into functions\n// ----------------------------------------------------------------------------\n\nexport interface ISpecialDefinition {\n  arity: number;\n  applyAsync: E.SpecialApplicationAsync;\n  // TODO: Test these implementations\n  applySync: E.SpecialApplicationSync;\n  checkArity?: (args: E.Expression[]) => boolean;\n}\n\nexport const specialDefinitions: Record<C.SpecialOperator, ISpecialDefinition> = {\n  // --------------------------------------------------------------------------\n  // Functional Forms\n  // https://www.w3.org/TR/sparql11-query/#func-forms\n  // --------------------------------------------------------------------------\n  bound,\n  if: ifSPARQL,\n  coalesce,\n  '&&': logicalAnd,\n  '||': logicalOr,\n  sameterm: sameTerm,\n  in: inSPARQL,\n  notin: notInSPARQL,\n\n  // Annoying functions\n  concat,\n\n  // Context dependent functions\n  now,\n  iri: IRI,\n  uri: IRI,\n  BNODE,\n};\n\n"]}