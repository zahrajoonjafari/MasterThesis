{"version":3,"file":"OverloadTree.js","sourceRoot":"","sources":["../../../lib/functions/OverloadTree.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as LRUCache from 'lru-cache';\nimport type { ICompleteSharedContext } from '../evaluators/evaluatorHelpers/BaseExpressionEvaluator';\nimport type * as E from '../expressions';\nimport { isLiteralTermExpression } from '../expressions';\nimport type { KnownLiteralTypes } from '../util/Consts';\nimport { TypeURL } from '../util/Consts';\nimport type { ISuperTypeProvider, OverrideType,\n  GeneralSuperTypeDict } from '../util/TypeHandling';\nimport {\n  superTypeDictTable,\n  getSuperTypes,\n  isKnownLiteralType,\n} from '../util/TypeHandling';\nimport type { ArgumentType } from './Core';\nimport { double, float, string } from './Helpers';\n\nexport type SearchStack = OverloadTree[];\nexport type ImplementationFunction = (sharedContext: ICompleteSharedContext) => E.SimpleApplication;\nexport type OverLoadCache = LRUCache<string, ImplementationFunction | undefined>;\n/**\n * Maps argument types on their specific implementation in a tree like structure.\n * When adding any functionality to this class, make sure you add it to SpecialFunctions as well.\n */\nexport class OverloadTree {\n  private implementation?: ImplementationFunction | undefined;\n  // We need this field. e.g. decimal decimal should be kept even when double double is added.\n  // We use promotion count to check priority.\n  private promotionCount?: number | undefined;\n  private readonly subTrees: Record<ArgumentType, OverloadTree>;\n  private readonly depth: number;\n\n  public constructor(private readonly identifier: string, depth?: number) {\n    this.implementation = undefined;\n    this.subTrees = Object.create(null);\n    this.depth = depth || 0;\n    this.promotionCount = undefined;\n  }\n\n  /**\n   * Get the implementation for the types that exactly match @param args .\n   */\n  public getImplementationExact(args: ArgumentType[]): ImplementationFunction | undefined {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this\n    let node: OverloadTree = this;\n    for (const expression of args) {\n      node = node.subTrees[expression];\n      if (!node) {\n        return undefined;\n      }\n    }\n    return node.implementation;\n  }\n\n  private getOverloadCacheIdentifier(args: E.TermExpression[]): string {\n    return this.identifier + args.map(term => {\n      const literalExpression = isLiteralTermExpression(term);\n      return literalExpression ? literalExpression.dataType : term.termType;\n    }).join('');\n  }\n\n  /**\n   * Searches in a depth first way for the best matching overload. considering this a the tree's root.\n   * @param args:\n   * @param overloadCache\n   * @param superTypeProvider\n   */\n  public search(args: E.TermExpression[], superTypeProvider: ISuperTypeProvider,\n    overloadCache: OverLoadCache): ImplementationFunction | undefined {\n    const identifier = this.getOverloadCacheIdentifier(args);\n    if (overloadCache.has(identifier)) {\n      return overloadCache.get(identifier);\n    }\n    // SearchStack is a stack of all node's that need to be checked for implementation.\n    // It provides an easy way to keep order in our search.\n    const searchStack: { node: OverloadTree; index: number }[] = [];\n    const startIndex = 0;\n    if (args.length === 0) {\n      return this.implementation;\n    }\n    // GetSubTreeWithArg return a SearchStack containing the node's that should be contacted next.\n    // We also log the index since there is no other way to remember this index.\n    // the provided stack should be pushed on top of our search stack since it also has it's order.\n    searchStack.push(...this.getSubTreeWithArg(args[startIndex], superTypeProvider).map(node =>\n      ({ node, index: startIndex + 1 })));\n    while (searchStack.length > 0) {\n      const { index, node } = <{ node: OverloadTree; index: number }>searchStack.pop();\n      // We check the implementation because it would be possible a path is created but not implemented.\n      // ex: f(double, double, double) and f(term, term). and calling f(double, double).\n      if (index === args.length && node.implementation) {\n        overloadCache.set(identifier, node.implementation);\n        return node.implementation;\n      }\n      searchStack.push(...node.getSubTreeWithArg(args[index], superTypeProvider).map(item =>\n        ({ node: item, index: index + 1 })));\n    }\n    // Calling a function with one argument but finding no implementation should return no implementation.\n    // Not even the one with no arguments.\n    overloadCache.set(identifier, undefined);\n    return undefined;\n  }\n\n  /**\n   * Adds an overload to the tree structure considering this as the tree's root.\n   * @param argumentTypes a list of ArgumentTypes that would need to be provided in the same order to\n   * get the implementation.\n   * @param func the implementation for this overload.\n   */\n  public addOverload(argumentTypes: ArgumentType[], func: ImplementationFunction): void {\n    this._addOverload([ ...argumentTypes ], func, 0);\n  }\n\n  private _addOverload(argumentTypes: ArgumentType[], func: ImplementationFunction, promotionCount: number): void {\n    const [ argumentType, ..._argumentTypes ] = argumentTypes;\n    if (!argumentType) {\n      if (this.promotionCount === undefined || promotionCount <= this.promotionCount) {\n        this.promotionCount = promotionCount;\n        this.implementation = func;\n      }\n      return;\n    }\n    if (!this.subTrees[argumentType]) {\n      this.subTrees[argumentType] = new OverloadTree(this.identifier, this.depth + 1);\n    }\n    this.subTrees[argumentType]._addOverload(_argumentTypes, func, promotionCount);\n    // Defined by https://www.w3.org/TR/xpath-31/#promotion .\n    // e.g. When a function takes a string, it can also accept a XSD_ANY_URI if it's cast first.\n    // TODO: When promoting decimal type a cast needs to be preformed.\n    if (argumentType === TypeURL.XSD_STRING) {\n      this.addPromotedOverload(TypeURL.XSD_ANY_URI, func, arg =>\n        string(arg.str()), _argumentTypes, promotionCount);\n    }\n    // TODO: in case of decimal a round needs to happen.\n    if (argumentType === TypeURL.XSD_DOUBLE) {\n      this.addPromotedOverload(TypeURL.XSD_FLOAT, func, arg =>\n        double((<E.NumericLiteral>arg).typedValue), _argumentTypes, promotionCount);\n      this.addPromotedOverload(TypeURL.XSD_DECIMAL, func, arg =>\n        double((<E.NumericLiteral>arg).typedValue), _argumentTypes, promotionCount);\n    }\n    if (argumentType === TypeURL.XSD_FLOAT) {\n      this.addPromotedOverload(TypeURL.XSD_DECIMAL, func, arg =>\n        float((<E.NumericLiteral>arg).typedValue), _argumentTypes, promotionCount);\n    }\n  }\n\n  private addPromotedOverload(typeToPromote: ArgumentType, func: ImplementationFunction,\n    conversionFunction: (arg: E.TermExpression) => E.TermExpression, argumentTypes: ArgumentType[],\n    promotionCount: number): void {\n    if (!this.subTrees[typeToPromote]) {\n      this.subTrees[typeToPromote] = new OverloadTree(this.identifier, this.depth + 1);\n    }\n    this.subTrees[typeToPromote]._addOverload(argumentTypes, funcConf => args => func(funcConf)([\n      ...args.slice(0, this.depth),\n      conversionFunction(args[this.depth]),\n      ...args.slice(this.depth + 1, args.length),\n    ]), promotionCount + 1);\n  }\n\n  /**\n   * @param arg term to try and match to possible overloads of this node.\n   * @returns SearchStack a stack with top element the next node that should be asked for implementation or overload.\n   */\n  private getSubTreeWithArg(arg: E.TermExpression, openWorldType: ISuperTypeProvider): SearchStack {\n    const res: SearchStack = [];\n    const literalExpression = isLiteralTermExpression(arg);\n    // These types refer to Type exported by lib/util/Consts.ts\n    if (this.subTrees.term) {\n      res.push(this.subTrees.term);\n    }\n    // TermTypes are defined in E.TermType.\n    if (this.subTrees[arg.termType]) {\n      res.push(this.subTrees[arg.termType]);\n    }\n    if (literalExpression) {\n      // Defending implementation. Mainly the scary sort.\n      // This function has cost O(n) + O(m * log(m)) with n = amount of overloads and m = amount of matched overloads\n      // We map over each of the overloads, filter only the once that can be used (this is normally 1 or 2).\n      // The sort function on an array with 1 or 2 arguments will be negligible.\n      const concreteType = isKnownLiteralType(literalExpression.dataType);\n      let subExtensionTable: GeneralSuperTypeDict;\n      if (concreteType) {\n        // Concrete dataType is known by sparqlee.\n        subExtensionTable = superTypeDictTable[concreteType];\n      } else {\n        // Datatype is a custom datatype\n        subExtensionTable = getSuperTypes(literalExpression.dataType, openWorldType);\n      }\n      const overLoads = <[OverrideType, OverloadTree][]> Object.entries(this.subTrees);\n      const matches: [number, OverloadTree][] = overLoads.filter(([ matchType, _ ]) => matchType in subExtensionTable)\n        .map(([ matchType, tree ]) => [ subExtensionTable[<KnownLiteralTypes> matchType], tree ]);\n      matches.sort(([ prioA, matchTypeA ], [ prioB, matchTypeB ]) => prioA - prioB);\n      res.push(...matches.map(([ _, sortedType ]) => sortedType));\n    }\n    return res;\n  }\n}\n\n"]}