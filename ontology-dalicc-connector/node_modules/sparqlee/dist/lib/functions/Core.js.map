{"version":3,"file":"Core.js","sourceRoot":"","sources":["../../../lib/functions/Core.ts"],"names":[],"mappings":"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","sourcesContent":["// eslint-disable-next-line no-redeclare\nimport type { Map } from 'immutable';\nimport { List } from 'immutable';\n\nimport type * as E from '../expressions';\nimport type * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\n\ntype Term = E.TermExpression;\n\n// ----------------------------------------------------------------------------\n// Overloaded Functions\n// ----------------------------------------------------------------------------\n\n// Maps argument types on their specific implementation.\nexport type OverloadMap = Map<List<ArgumentType>, E.SimpleApplication>;\n\n// Function and operator arguments are 'flattened' in the SPARQL spec.\n// If the argument is a literal, the datatype often also matters.\nexport type ArgumentType = 'term' | E.TermType | C.Type;\n\nexport interface IOverloadedDefinition {\n  arity: number | number[];\n  overloads: OverloadMap;\n}\n\nexport abstract class BaseFunction<Operator> {\n  public arity: number | number[];\n  private readonly overloads: OverloadMap;\n\n  protected constructor(public operator: Operator, definition: IOverloadedDefinition) {\n    this.arity = definition.arity;\n    this.overloads = definition.overloads;\n  }\n\n  /**\n   * A function application works by monomorphing the function to a specific\n   * instance depending on the runtime types. We then just apply this function\n   * to the args.\n   */\n  public apply = (args: Term[]): Term => {\n    const concreteFunction = this.monomorph(args) || this.handleInvalidTypes(args);\n    return concreteFunction(args);\n  };\n\n  protected abstract handleInvalidTypes(args: Term[]): never;\n\n  /**\n   * We monomorph by checking the map of overloads for keys corresponding\n   * to the runtime types. We start by checking for an implementation for the\n   * most concrete types (integer, string, date, IRI), if we find none,\n   * we consider their term types (literal, blank, IRI), and lastly we consider\n   * all arguments as generic terms.\n   *\n   * Another option would be to populate the overloads with an implementation\n   * for every concrete type when the function is generic over termtypes or\n   * terms.\n   */\n  private monomorph(args: Term[]): E.SimpleApplication {\n    return false ||\n      // TODO: Maybe use non primitive types first?\n      this.overloads.get(Typer.asConcreteTypes(args)) ||\n      this.overloads.get(Typer.asTermTypes(args)) ||\n      this.overloads.get(Typer.asGenericTerms(args));\n  }\n}\n\nconst Typer = {\n  asConcreteTypes(args: Term[]): List<ArgumentType> {\n    return List(args.map((term: any) => term.type || term.termType));\n  },\n\n  asTermTypes(args: Term[]): List<E.TermType> {\n    return List(args.map((term: E.TermExpression) => term.termType));\n  },\n\n  asGenericTerms(args: Term[]): List<'term'> {\n    return <List<'term'>> List(Array.from({ length: args.length }).fill('term'));\n  },\n};\n\n// Regular Functions ----------------------------------------------------------\n\n/**\n * Varying kinds of functions take arguments of different types on which the\n * specific behaviour is dependant. Although their behaviour is often varying,\n * it is always relatively simple, and better suited for synced behaviour.\n * The types of their arguments are always terms, but might differ in\n * their term-type (eg: iri, literal),\n * their specific literal type (eg: string, integer),\n * their arity (see BNODE),\n * or even their specific numeric type (eg: integer, float).\n *\n * Examples include:\n *  - Arithmetic operations such as: *, -, /, +\n *  - Bool operators such as: =, !=, <=, <, ...\n *  - Functions such as: str, IRI\n *\n * See also: https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n * and https://www.w3.org/TR/sparql11-query/#OperatorMapping\n */\nexport class RegularFunction extends BaseFunction<C.RegularOperator> {\n  protected functionClass: 'regular' = 'regular';\n\n  public constructor(op: C.RegularOperator, definition: IOverloadedDefinition) {\n    super(op, definition);\n  }\n\n  protected handleInvalidTypes(args: Term[]): never {\n    throw new Err.InvalidArgumentTypes(args, this.operator);\n  }\n}\n\n// Named Functions ------------------------------------------------------------\nexport class NamedFunction extends BaseFunction<C.NamedOperator> {\n  protected functionClass: 'named' = 'named';\n\n  public constructor(op: C.NamedOperator, definition: IOverloadedDefinition) {\n    super(op, definition);\n  }\n\n  protected handleInvalidTypes(args: Term[]): never {\n    throw new Err.InvalidArgumentTypes(args, this.operator);\n  }\n}\n\n// Special Functions ----------------------------------------------------------\n/**\n * Special Functions are those that don't really fit in sensible categories and\n * have extremely heterogeneous signatures that make them impossible to abstract\n * over. They are small in number, and their behaviour is often complex and open\n * for multiple correct implementations with different trade-offs.\n *\n * Due to their varying nature, they need all available information present\n * during evaluation. This reflects in the signature of the apply() method.\n *\n * They need access to an evaluator to be able to even implement their logic.\n * Especially relevant for IF, and the logical connectives.\n *\n * They can have both sync and async implementations, and both would make sense\n * in some contexts.\n */\nexport class SpecialFunction {\n  public functionClass: 'special' = 'special';\n  public arity: number;\n  public applySync: E.SpecialApplicationSync;\n  public applyAsync: E.SpecialApplicationAsync;\n  public checkArity: (args: E.Expression[]) => boolean;\n\n  public constructor(public operator: C.SpecialOperator, definition: ISpecialDefinition) {\n    this.arity = definition.arity;\n    this.applySync = definition.applySync;\n    this.applyAsync = definition.applyAsync;\n    this.checkArity = definition.checkArity || defaultArityCheck(this.arity);\n  }\n}\n\nfunction defaultArityCheck(arity: number): (args: E.Expression[]) => boolean {\n  return (args: E.Expression[]): boolean => {\n    // Infinity is used to represent var-args, so it's always correct.\n    if (arity === Number.POSITIVE_INFINITY) {\n      return true;\n    }\n\n    // If the function has overloaded arity, the actual arity needs to be present.\n    if (Array.isArray(arity)) {\n      return arity.includes(args.length);\n    }\n\n    return args.length === arity;\n  };\n}\n\nexport interface ISpecialDefinition {\n  arity: number;\n  applyAsync: E.SpecialApplicationAsync;\n  applySync: E.SpecialApplicationSync;\n  checkArity?: (args: E.Expression[]) => boolean;\n}\n\n// Type Promotion -------------------------------------------------------------\n\nconst _promote: {[t in C.PrimitiveNumericType]: {[tt in C.PrimitiveNumericType]: C.PrimitiveNumericType }} = {\n  integer: {\n    integer: 'integer',\n    decimal: 'decimal',\n    float: 'float',\n    double: 'double',\n  },\n  decimal: {\n    integer: 'decimal',\n    decimal: 'decimal',\n    float: 'float',\n    double: 'double',\n  },\n  float: {\n    integer: 'float',\n    decimal: 'float',\n    float: 'float',\n    double: 'double',\n  },\n  double: {\n    integer: 'double',\n    decimal: 'double',\n    float: 'double',\n    double: 'double',\n  },\n};\n\nexport function promote(left: C.PrimitiveNumericType, right: C.PrimitiveNumericType): C.PrimitiveNumericType {\n  return _promote[left][right];\n}\n"]}