import type * as RDF from '@rdfjs/types';
import * as C from '../util/Consts';
import type { TermExpression, TermType } from './Expressions';
import { ExpressionType } from './Expressions';
export declare abstract class Term implements TermExpression {
    expressionType: ExpressionType.Term;
    abstract termType: TermType;
    abstract toRDF(): RDF.Term;
    str(): string;
    coerceEBV(): boolean;
}
export declare class NamedNode extends Term {
    value: string;
    termType: TermType;
    constructor(value: string);
    toRDF(): RDF.Term;
    str(): string;
}
export declare class BlankNode extends Term {
    static _nextID: number;
    value: RDF.BlankNode;
    termType: TermType;
    constructor(value: RDF.BlankNode | string);
    static nextID(): string;
    toRDF(): RDF.Term;
}
export declare class Literal<T> extends Term {
    typedValue: T;
    typeURL: RDF.NamedNode;
    strValue?: string;
    language?: string;
    termType: 'literal';
    type: C.Type;
    constructor(typedValue: T, typeURL: RDF.NamedNode, strValue?: string, language?: string);
    toRDF(): RDF.Term;
    str(): string;
}
export declare class NumericLiteral extends Literal<number> {
    private static readonly specificFormatters;
    type: C.PrimitiveNumericType;
    coerceEBV(): boolean;
    toRDF(): RDF.Term;
    str(): string;
}
export declare class BooleanLiteral extends Literal<boolean> {
    typedValue: boolean;
    strValue?: string;
    constructor(typedValue: boolean, strValue?: string);
    coerceEBV(): boolean;
}
export declare class DateTimeLiteral extends Literal<Date> {
    typedValue: Date;
    strValue: string;
    constructor(typedValue: Date, strValue: string);
}
export declare class LangStringLiteral extends Literal<string> {
    typedValue: string;
    language: string;
    constructor(typedValue: string, language: string);
    coerceEBV(): boolean;
}
export declare class StringLiteral extends Literal<string> {
    typedValue: string;
    constructor(typedValue: string);
    coerceEBV(): boolean;
}
/**
 * This class is used when a literal is parsed, and it's value is
 * an invalid lexical form for it's datatype. The spec defines value with
 * invalid lexical form are still valid terms, and as such we can not error
 * immediately. This class makes sure that the typedValue will remain undefined,
 * and the category 'nonlexical'. This way, only when operators apply to the
 * 'nonlexical' category, they will keep working, otherwise they will throw a
 * type error.
 * This seems to match the spec, except maybe for functions that accept
 * non-lexical values for their datatype.
 *
 * See:
 *  - https://www.w3.org/TR/xquery/#dt-type-error
 *  - https://www.w3.org/TR/rdf-concepts/#section-Literal-Value
 *  - https://www.w3.org/TR/xquery/#dt-ebv
 *  - ... some other more precise thing i can't find...
 */
export declare class NonLexicalLiteral extends Literal<undefined> {
    private readonly shouldBeCategory;
    constructor(typedValue: undefined, typeURL: RDF.NamedNode, strValue?: string, language?: string);
    coerceEBV(): boolean;
}
