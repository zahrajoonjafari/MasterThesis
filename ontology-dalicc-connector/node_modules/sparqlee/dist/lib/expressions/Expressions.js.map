{"version":3,"file":"Expressions.js","sourceRoot":"","sources":["../../../lib/expressions/Expressions.ts"],"names":[],"mappings":";;;AAKA,IAAY,cAUX;AAVD,WAAY,cAAc;IACxB,yCAAuB,CAAA;IACvB,yCAAuB,CAAA;IACvB,iCAAe,CAAA;IACf,uCAAqB,CAAA;IACrB,qDAAmC,CAAA;IACnC,+BAAa,CAAA;IACb,uCAAqB,CAAA;IACrB,mDAAiC,CAAA;IACjC,iDAA+B,CAAA;AACjC,CAAC,EAVW,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAUzB","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra } from 'sparqlalgebrajs';\n\nimport type { Bindings } from '../Types';\n\nexport enum ExpressionType {\n  Aggregate = 'aggregate',\n  Existence = 'existence',\n  Named = 'named',\n  Operator = 'operator',\n  SpecialOperator = 'specialOperator',\n  Term = 'term',\n  Variable = 'variable',\n  AsyncExtension = 'asyncExtension',\n  SyncExtension = 'syncExtension',\n}\n\nexport type Expression =\n  AggregateExpression |\n  ExistenceExpression |\n  NamedExpression |\n  OperatorExpression |\n  SpecialOperatorExpression |\n  TermExpression |\n  VariableExpression |\n  AsyncExtensionExpression |\n  SyncExtensionExpression;\n\nexport interface IExpressionProps {\n  expressionType: ExpressionType;\n}\n\nexport type AggregateExpression = IExpressionProps & {\n  expressionType: ExpressionType.Aggregate;\n  name: string;\n  expression: Algebra.AggregateExpression;\n};\n\nexport type ExistenceExpression = IExpressionProps & {\n  expressionType: ExpressionType.Existence;\n  expression: Algebra.ExistenceExpression;\n};\n\nexport type NamedExpression = IExpressionProps & {\n  expressionType: ExpressionType.Named;\n  name: RDF.NamedNode;\n  apply: SimpleApplication;\n  args: Expression[];\n};\n\nexport type AsyncExtensionExpression = IExpressionProps & {\n  expressionType: ExpressionType.AsyncExtension;\n  name: RDF.NamedNode;\n  apply: AsyncExtensionApplication;\n  args: Expression[];\n};\n\nexport type SyncExtensionExpression = IExpressionProps & {\n  expressionType: ExpressionType.SyncExtension;\n  name: RDF.NamedNode;\n  apply: SimpleApplication;\n  args: Expression[];\n};\n\n// Export type Application = SimpleApplication | SpecialApplication;\nexport type SimpleApplication = (args: TermExpression[]) => TermExpression;\nexport type AsyncExtensionApplication = (args: TermExpression[]) => Promise<TermExpression>;\n\nexport type OperatorExpression = IExpressionProps & {\n  expressionType: ExpressionType.Operator;\n  args: Expression[];\n  apply: SimpleApplication;\n};\n\nexport type SpecialApplication<Term, BNode> = (context: IEvalContext<Term, BNode>) => Term;\n\nexport type SpecialApplicationAsync = SpecialApplication<Promise<TermExpression>, Promise<RDF.BlankNode>>;\nexport type EvalContextAsync = IEvalContext<Promise<TermExpression>, Promise<RDF.BlankNode>>;\n\nexport type SpecialApplicationSync = SpecialApplication<TermExpression, RDF.BlankNode>;\nexport type EvalContextSync = IEvalContext<TermExpression, RDF.BlankNode>;\n\nexport interface IEvalContext<Term, BNode> {\n  args: Expression[];\n  mapping: Bindings;\n  context: {\n    now: Date;\n    baseIRI?: string;\n    bnode: (input?: string) => BNode;\n  };\n  evaluate: (expr: Expression, mapping: Bindings) => Term;\n}\n\nexport type SpecialOperatorExpression = IExpressionProps & {\n  expressionType: ExpressionType.SpecialOperator;\n  args: Expression[];\n  applyAsync: SpecialApplicationAsync;\n  applySync: SpecialApplicationSync;\n};\n\n// TODO: Create alias Term = TermExpression\nexport type TermType = 'namedNode' | 'literal' | 'blankNode';\nexport type TermExpression = IExpressionProps & {\n  expressionType: ExpressionType.Term;\n  termType: TermType;\n  str: () => string;\n  coerceEBV: () => boolean;\n  toRDF: () => RDF.Term;\n};\n\nexport type VariableExpression = IExpressionProps & {\n  expressionType: ExpressionType.Variable;\n  name: string;\n};\n"]}