{"version":3,"file":"Term.js","sourceRoot":"","sources":["../../../lib/expressions/Term.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\n\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\nimport type { TermExpression, TermType } from './Expressions';\nimport { ExpressionType } from './Expressions';\n\nconst DF = new DataFactory();\n\nexport abstract class Term implements TermExpression {\n  public expressionType: ExpressionType.Term = ExpressionType.Term;\n  abstract termType: TermType;\n\n  abstract toRDF(): RDF.Term;\n\n  public str(): string {\n    throw new Err.InvalidArgumentTypes([ this ], C.RegularOperator.STR);\n  }\n\n  public coerceEBV(): boolean {\n    throw new Err.EBVCoercionError(this);\n  }\n}\n\n// NamedNodes -----------------------------------------------------------------\nexport class NamedNode extends Term {\n  public termType: TermType = 'namedNode';\n  public constructor(public value: string) {\n    super();\n  }\n\n  public toRDF(): RDF.Term {\n    return DF.namedNode(this.value);\n  }\n\n  public str(): string {\n    return this.value;\n  }\n}\n\n// BlankNodes -----------------------------------------------------------------\n\nexport class BlankNode extends Term {\n  public static _nextID = 0;\n\n  public value: RDF.BlankNode;\n  public termType: TermType = 'blankNode';\n\n  public constructor(value: RDF.BlankNode | string) {\n    super();\n    this.value = typeof value === 'string' ? DF.blankNode(value) : value;\n  }\n\n  public static nextID(): string {\n    BlankNode._nextID += 1;\n    return BlankNode.nextID.toString();\n  }\n\n  public toRDF(): RDF.Term {\n    return this.value;\n  }\n}\n\n// Literals-- -----------------------------------------------------------------\nexport class Literal<T> extends Term {\n  public termType: 'literal' = 'literal';\n  public type: C.Type;\n\n  public constructor(\n    public typedValue: T,\n    public typeURL: RDF.NamedNode,\n    public strValue?: string,\n    public language?: string,\n  ) {\n    super();\n    this.type = C.type(typeURL.value);\n  }\n\n  public toRDF(): RDF.Term {\n    return DF.literal(\n      this.strValue || this.str(),\n      this.language || this.typeURL,\n    );\n  }\n\n  public str(): string {\n    // eslint-disable-next-line @typescript-eslint/no-base-to-string\n    return this.strValue || this.typedValue.toString();\n  }\n}\n\nexport class NumericLiteral extends Literal<number> {\n  private static readonly specificFormatters: {[key in C.PrimitiveNumericType]: (val: number) => string } = {\n    // Avoid emitting non lexical integers\n    integer: value => value.toFixed(0),\n    float: value => value.toString(),\n    decimal: value => value.toString(),\n    // // Be consistent with float\n    // decimal: (value) => {\n    //   const jsDecimal = value.toString();\n    //   return jsDecimal.match(/\\./)\n    //     ? jsDecimal\n    //     : jsDecimal + '.0';\n    // },\n\n    // https://www.w3.org/TR/xmlschema-2/#double\n    double(value) {\n      const jsExponential = value.toExponential();\n      const [ jsMantisse, jsExponent ] = jsExponential.split('e');\n\n      // Leading + must be removed for integer\n      // https://www.w3.org/TR/xmlschema-2/#integer\n      const exponent = jsExponent.replace(/\\+/u, '');\n\n      // SPARQL test suite prefers trailing zero's\n      const mantisse = jsMantisse.includes('.') ?\n        jsMantisse :\n        `${jsMantisse}.0`;\n\n      return `${mantisse}E${exponent}`;\n    },\n  };\n\n  public type: C.PrimitiveNumericType;\n\n  public coerceEBV(): boolean {\n    return !!this.typedValue;\n  }\n\n  public toRDF(): RDF.Term {\n    const term = super.toRDF();\n    if (!Number.isFinite(this.typedValue)) {\n      term.value = term.value.replace('Infinity', 'INF');\n    }\n    return term;\n  }\n\n  public str(): string {\n    return this.strValue ||\n      NumericLiteral.specificFormatters[this.type](this.typedValue);\n  }\n}\n\nexport class BooleanLiteral extends Literal<boolean> {\n  public constructor(public typedValue: boolean, public strValue?: string) {\n    super(typedValue, C.make(C.TypeURL.XSD_BOOLEAN), strValue);\n  }\n\n  public coerceEBV(): boolean {\n    return !!this.typedValue;\n  }\n}\n\nexport class DateTimeLiteral extends Literal<Date> {\n  // StrValue is mandatory here because toISOString will always add\n  // milliseconds, even if they were not present.\n  public constructor(public typedValue: Date, public strValue: string) {\n    super(typedValue, C.make(C.TypeURL.XSD_DATE_TIME), strValue);\n  }\n}\n\nexport class LangStringLiteral extends Literal<string> {\n  public constructor(public typedValue: string, public language: string) {\n    super(typedValue, C.make(C.TypeURL.RDF_LANG_STRING), typedValue, language);\n  }\n\n  public coerceEBV(): boolean {\n    return this.strValue.length > 0;\n  }\n}\n\n// https://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal\n// https://www.w3.org/TR/sparql11-query/#defn_SimpleLiteral\n// https://www.w3.org/TR/sparql11-query/#func-strings\n// This does not include language tagged literals\nexport class StringLiteral extends Literal<string> {\n  public constructor(public typedValue: string) {\n    super(typedValue, C.make(C.TypeURL.XSD_STRING), typedValue);\n  }\n\n  public coerceEBV(): boolean {\n    return this.strValue.length > 0;\n  }\n}\n\n/**\n * This class is used when a literal is parsed, and it's value is\n * an invalid lexical form for it's datatype. The spec defines value with\n * invalid lexical form are still valid terms, and as such we can not error\n * immediately. This class makes sure that the typedValue will remain undefined,\n * and the category 'nonlexical'. This way, only when operators apply to the\n * 'nonlexical' category, they will keep working, otherwise they will throw a\n * type error.\n * This seems to match the spec, except maybe for functions that accept\n * non-lexical values for their datatype.\n *\n * See:\n *  - https://www.w3.org/TR/xquery/#dt-type-error\n *  - https://www.w3.org/TR/rdf-concepts/#section-Literal-Value\n *  - https://www.w3.org/TR/xquery/#dt-ebv\n *  - ... some other more precise thing i can't find...\n */\nexport class NonLexicalLiteral extends Literal<undefined> {\n  private readonly shouldBeCategory: C.Type;\n  public constructor(\n    typedValue: undefined,\n    typeURL: RDF.NamedNode,\n    strValue?: string,\n    language?: string,\n  ) {\n    super(typedValue, typeURL, strValue, language);\n    this.typedValue = undefined;\n    this.type = 'nonlexical';\n    this.shouldBeCategory = C.type(typeURL.value);\n  }\n\n  public coerceEBV(): boolean {\n    const isNumericOrBool =\n      C.PrimitiveNumericTypes.has(this.shouldBeCategory) ||\n      this.shouldBeCategory === 'boolean';\n\n    if (isNumericOrBool) {\n      return false;\n    }\n    throw new Err.EBVCoercionError(this);\n  }\n}\n"]}