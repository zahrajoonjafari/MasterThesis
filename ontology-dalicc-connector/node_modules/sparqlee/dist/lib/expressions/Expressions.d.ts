import type * as RDF from '@rdfjs/types';
import type { Algebra } from 'sparqlalgebrajs';
import type { Bindings } from '../Types';
export declare enum ExpressionType {
    Aggregate = "aggregate",
    Existence = "existence",
    Named = "named",
    Operator = "operator",
    SpecialOperator = "specialOperator",
    Term = "term",
    Variable = "variable",
    AsyncExtension = "asyncExtension",
    SyncExtension = "syncExtension"
}
export declare type Expression = AggregateExpression | ExistenceExpression | NamedExpression | OperatorExpression | SpecialOperatorExpression | TermExpression | VariableExpression | AsyncExtensionExpression | SyncExtensionExpression;
export interface IExpressionProps {
    expressionType: ExpressionType;
}
export declare type AggregateExpression = IExpressionProps & {
    expressionType: ExpressionType.Aggregate;
    name: string;
    expression: Algebra.AggregateExpression;
};
export declare type ExistenceExpression = IExpressionProps & {
    expressionType: ExpressionType.Existence;
    expression: Algebra.ExistenceExpression;
};
export declare type NamedExpression = IExpressionProps & {
    expressionType: ExpressionType.Named;
    name: RDF.NamedNode;
    apply: SimpleApplication;
    args: Expression[];
};
export declare type AsyncExtensionExpression = IExpressionProps & {
    expressionType: ExpressionType.AsyncExtension;
    name: RDF.NamedNode;
    apply: AsyncExtensionApplication;
    args: Expression[];
};
export declare type SyncExtensionExpression = IExpressionProps & {
    expressionType: ExpressionType.SyncExtension;
    name: RDF.NamedNode;
    apply: SimpleApplication;
    args: Expression[];
};
export declare type SimpleApplication = (args: TermExpression[]) => TermExpression;
export declare type AsyncExtensionApplication = (args: TermExpression[]) => Promise<TermExpression>;
export declare type OperatorExpression = IExpressionProps & {
    expressionType: ExpressionType.Operator;
    args: Expression[];
    apply: SimpleApplication;
};
export declare type SpecialApplication<Term, BNode> = (context: IEvalContext<Term, BNode>) => Term;
export declare type SpecialApplicationAsync = SpecialApplication<Promise<TermExpression>, Promise<RDF.BlankNode>>;
export declare type EvalContextAsync = IEvalContext<Promise<TermExpression>, Promise<RDF.BlankNode>>;
export declare type SpecialApplicationSync = SpecialApplication<TermExpression, RDF.BlankNode>;
export declare type EvalContextSync = IEvalContext<TermExpression, RDF.BlankNode>;
export interface IEvalContext<Term, BNode> {
    args: Expression[];
    mapping: Bindings;
    context: {
        now: Date;
        baseIRI?: string;
        bnode: (input?: string) => BNode;
    };
    evaluate: (expr: Expression, mapping: Bindings) => Term;
}
export declare type SpecialOperatorExpression = IExpressionProps & {
    expressionType: ExpressionType.SpecialOperator;
    args: Expression[];
    applyAsync: SpecialApplicationAsync;
    applySync: SpecialApplicationSync;
};
export declare type TermType = 'namedNode' | 'literal' | 'blankNode';
export declare type TermExpression = IExpressionProps & {
    expressionType: ExpressionType.Term;
    termType: TermType;
    str: () => string;
    coerceEBV: () => boolean;
    toRDF: () => RDF.Term;
};
export declare type VariableExpression = IExpressionProps & {
    expressionType: ExpressionType.Variable;
    name: string;
};
