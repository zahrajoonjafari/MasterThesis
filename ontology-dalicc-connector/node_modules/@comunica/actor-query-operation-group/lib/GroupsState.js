"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupsState = void 0;
const actor_abstract_bindings_hash_1 = require("@comunica/actor-abstract-bindings-hash");
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const rdf_string_1 = require("rdf-string");
const sparqlee_1 = require("sparqlee");
/**
 * A state manager for the groups constructed by consuming the bindings-stream.
 */
class GroupsState {
    constructor(pattern, sparqleeConfig) {
        this.pattern = pattern;
        this.sparqleeConfig = sparqleeConfig;
        this.groups = new Map();
        this.groupsInitializer = new Map();
        this.groupVariables = new Set(this.pattern.variables.map(x => rdf_string_1.termToString(x)));
        this.distinctHashes = pattern.aggregates.some(({ distinct }) => distinct) ?
            new Map() :
            null;
        this.waitCounter = 1;
        this.resultHasBeenCalled = false;
    }
    /**
     * - Consumes a stream binding
     * - Find the corresponding group and create one if need be
     * - Feeds the binding to the group's aggregators
     *
     * @param {Bindings} bindings - The Bindings to consume
     */
    consumeBindings(bindings) {
        const check = this.resultCheck();
        if (check) {
            return check;
        }
        // We increment the counter and decrement him when put action is performed.
        this.waitCounter++;
        // Select the bindings on which we group
        const grouper = bindings
            .filter((_, variable) => this.groupVariables.has(variable))
            .toMap();
        const groupHash = this.hashBindings(grouper);
        // First member of group -> create new group
        let groupInitializer = this.groupsInitializer.get(groupHash);
        let res;
        if (!groupInitializer) {
            // Initialize state for all aggregators for new group
            groupInitializer = (async () => {
                const aggregators = {};
                await Promise.all(this.pattern.aggregates.map(async (aggregate) => {
                    const key = rdf_string_1.termToString(aggregate.variable);
                    aggregators[key] = new sparqlee_1.AsyncAggregateEvaluator(aggregate, this.sparqleeConfig);
                    await aggregators[key].put(bindings);
                }));
                if (this.distinctHashes) {
                    const bindingsHash = this.hashBindings(bindings);
                    this.distinctHashes.set(groupHash, new Set([bindingsHash]));
                }
                const group = { aggregators, bindings: grouper };
                this.groups.set(groupHash, group);
                this.subtractWaitCounterAndCollect();
                return group;
            })();
            this.groupsInitializer.set(groupHash, groupInitializer);
            res = groupInitializer;
        }
        else {
            const groupInitializerDefined = groupInitializer;
            res = (async () => {
                const group = await groupInitializerDefined;
                await Promise.all(this.pattern.aggregates.map(async (aggregate) => {
                    // If distinct, check first whether we have inserted these values already
                    if (aggregate.distinct) {
                        const hash = this.hashBindings(bindings);
                        if (this.distinctHashes.get(groupHash).has(hash)) {
                            return;
                        }
                        this.distinctHashes.get(groupHash).add(hash);
                    }
                    const variable = rdf_string_1.termToString(aggregate.variable);
                    await group.aggregators[variable].put(bindings);
                }));
            })().then(() => {
                this.subtractWaitCounterAndCollect();
            });
        }
        return res;
    }
    subtractWaitCounterAndCollect() {
        if (--this.waitCounter === 0) {
            this.handleResultCollection();
        }
    }
    handleResultCollection() {
        // Collect groups
        let rows = [...this.groups].map(([_, group]) => {
            const { bindings: groupBindings, aggregators } = group;
            // Collect aggregator bindings
            // If the aggregate errorred, the result will be undefined
            const aggBindings = {};
            for (const variable in aggregators) {
                const value = aggregators[variable].result();
                if (value !== undefined) {
                    // Filter undefined
                    aggBindings[variable] = value;
                }
            }
            // Merge grouping bindings and aggregator bindings
            return groupBindings.merge(aggBindings);
        });
        // Case: No Input
        // Some aggregators still define an output on the empty input
        // Result is a single Bindings
        if (rows.length === 0 && this.groupVariables.size === 0) {
            const single = {};
            for (const aggregate of this.pattern.aggregates) {
                const key = rdf_string_1.termToString(aggregate.variable);
                const value = sparqlee_1.AsyncAggregateEvaluator.emptyValue(aggregate);
                if (value !== undefined) {
                    single[key] = value;
                }
            }
            rows = [bus_query_operation_1.Bindings(single)];
        }
        this.waitResolver(rows);
    }
    resultCheck() {
        if (this.resultHasBeenCalled) {
            return Promise.reject(new Error('Calling any function after calling collectResult is invalid.'));
        }
    }
    /**
     * Collect the result of the final state. This returns a Bindings per group,
     * and a (possibly empty) Bindings in case no Bindings have been consumed yet.
     * You can only call this method once, after calling this method,
     * calling any function on this will result in an error being thrown.
     */
    collectResults() {
        const check = this.resultCheck();
        if (check) {
            return check;
        }
        this.resultHasBeenCalled = true;
        const res = new Promise(resolve => {
            this.waitResolver = resolve;
        });
        this.subtractWaitCounterAndCollect();
        return res;
    }
    /**
     * @param {Bindings} bindings - Bindings to hash
     */
    hashBindings(bindings) {
        return actor_abstract_bindings_hash_1.AbstractFilterHash.hash(bindings);
    }
}
exports.GroupsState = GroupsState;
//# sourceMappingURL=GroupsState.js.map