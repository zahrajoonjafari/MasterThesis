"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorHttpNodeFetch = void 0;
const bus_http_1 = require("@comunica/bus-http");
const context_entries_1 = require("@comunica/context-entries");
require("cross-fetch/polyfill");
const FetchInitPreprocessor_1 = require("./FetchInitPreprocessor");
/**
 * A node-fetch actor that listens on the 'init' bus.
 *
 * It will call `fetch` with either action.input or action.url.
 */
class ActorHttpNodeFetch extends bus_http_1.ActorHttp {
    constructor(args) {
        super(args);
        this.userAgent = ActorHttpNodeFetch.createUserAgent();
        this.fetchInitPreprocessor = new FetchInitPreprocessor_1.FetchInitPreprocessor(args.agentOptions ?
            JSON.parse(args.agentOptions) :
            undefined);
    }
    static createUserAgent() {
        return `Comunica/actor-http-node-fetch (${typeof global.navigator === 'undefined' ?
            `Node.js ${process.version}; ${process.platform}` :
            `Browser-${global.navigator.userAgent}`})`;
    }
    async test(action) {
        return { time: Number.POSITIVE_INFINITY };
    }
    run(action) {
        var _a, _b;
        // Prepare headers
        const initHeaders = action.init ? action.init.headers || {} : {};
        action.init = action.init ? action.init : {};
        action.init.headers = new Headers(initHeaders);
        if (!action.init.headers.has('user-agent')) {
            action.init.headers.append('user-agent', this.userAgent);
        }
        if (action.context && action.context.get(context_entries_1.KeysHttp.auth)) {
            action.init.headers.append('Authorization', `Basic ${Buffer.from(action.context.get(context_entries_1.KeysHttp.auth)).toString('base64')}`);
        }
        // Log request
        this.logInfo(action.context, `Requesting ${typeof action.input === 'string' ?
            action.input :
            action.input.url}`, () => ({
            headers: bus_http_1.ActorHttp.headersToHash(new Headers(action.init.headers)),
            method: action.init.method || 'GET',
        }));
        // TODO: remove this workaround once this has a fix: https://github.com/inrupt/solid-client-authn-js/issues/1708
        if (action.init && action.init.headers && 'append' in action.init.headers && ((_a = action.context) === null || _a === void 0 ? void 0 : _a.has(context_entries_1.KeysHttp.fetch))) {
            action.init.headers = bus_http_1.ActorHttp.headersToHash(action.init.headers);
        }
        // Perform request
        const customFetch = (_b = action
            .context) === null || _b === void 0 ? void 0 : _b.get(context_entries_1.KeysHttp.fetch);
        return (customFetch || fetch)(action.input, this.fetchInitPreprocessor.handle(Object.assign(Object.assign({}, action.init), action.context && action.context.get(context_entries_1.KeysHttp.includeCredentials) ? { credentials: 'include' } : {}))).then(response => {
            // Node-fetch does not support body.cancel, while it is mandatory according to the fetch and readablestream api.
            // If it doesn't exist, we monkey-patch it.
            if (response.body && !response.body.cancel) {
                response.body.cancel = async (error) => response.body.destroy(error);
            }
            return response;
        });
    }
}
exports.ActorHttpNodeFetch = ActorHttpNodeFetch;
//# sourceMappingURL=ActorHttpNodeFetch.js.map