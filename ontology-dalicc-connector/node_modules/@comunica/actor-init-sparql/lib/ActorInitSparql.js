"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorInitSparql = exports.KEY_CONTEXT_LENIENT = exports.KEY_CONTEXT_QUERYFORMAT = exports.KEY_CONTEXT_INITIALBINDINGS = void 0;
const fs_1 = require("fs");
const context_entries_1 = require("@comunica/context-entries");
const yargs_1 = require("yargs");
const ActorInitSparql_browser_1 = require("./ActorInitSparql-browser");
const CliArgsHandlerBase_1 = require("./cli/CliArgsHandlerBase");
const CliArgsHandlerQuery_1 = require("./cli/CliArgsHandlerQuery");
// eslint-disable-next-line no-duplicate-imports
var ActorInitSparql_browser_2 = require("./ActorInitSparql-browser");
Object.defineProperty(exports, "KEY_CONTEXT_INITIALBINDINGS", { enumerable: true, get: function () { return ActorInitSparql_browser_2.KEY_CONTEXT_INITIALBINDINGS; } });
Object.defineProperty(exports, "KEY_CONTEXT_QUERYFORMAT", { enumerable: true, get: function () { return ActorInitSparql_browser_2.KEY_CONTEXT_QUERYFORMAT; } });
Object.defineProperty(exports, "KEY_CONTEXT_LENIENT", { enumerable: true, get: function () { return ActorInitSparql_browser_2.KEY_CONTEXT_LENIENT; } });
/**
 * A comunica SPARQL Init Actor.
 */
class ActorInitSparql extends ActorInitSparql_browser_1.ActorInitSparql {
    constructor(args) {
        super(args);
    }
    async run(action) {
        var _a;
        const cliArgsHandlers = [
            new CliArgsHandlerBase_1.CliArgsHandlerBase(action.context),
            new CliArgsHandlerQuery_1.CliArgsHandlerQuery(this.defaultQueryInputFormat, this.queryString, this.context),
            ...((_a = action.context) === null || _a === void 0 ? void 0 : _a.get(context_entries_1.KeysInitSparql.cliArgsHandlers)) || [],
        ];
        // Populate yargs arguments object
        let argumentsBuilder = yargs_1.default({});
        for (const cliArgsHandler of cliArgsHandlers) {
            argumentsBuilder = cliArgsHandler.populateYargs(argumentsBuilder);
        }
        // Extract raw argument values from parsed yargs object, so that we can handle each of them hereafter
        let args;
        try {
            args = await argumentsBuilder.parse(action.argv);
        }
        catch (error) {
            return {
                stderr: require('streamify-string')(`${await argumentsBuilder.getHelp()}\n\n${error.message}\n`),
            };
        }
        // Print supported MIME types
        if (args.listformats) {
            const mediaTypes = await this.getResultMediaTypes();
            return { stdout: require('streamify-string')(`${Object.keys(mediaTypes).join('\n')}\n`) };
        }
        // Define query
        // We need to do this before the cliArgsHandlers, as we may modify the sources array
        let query;
        if (args.query) {
            query = args.query;
        }
        else if (args.file) {
            query = fs_1.readFileSync(args.file, { encoding: 'utf8' });
        }
        else if (args.sources.length > 0) {
            query = args.sources[args.sources.length - 1];
            args.sources.pop();
        }
        // Invoke args handlers to process any remaining args
        const context = {};
        try {
            for (const cliArgsHandler of cliArgsHandlers) {
                await cliArgsHandler.handleArgs(args, context);
            }
        }
        catch (error) {
            return { stderr: require('streamify-string')(error.message) };
        }
        // Evaluate query
        const queryResult = await this.query(query, context);
        // Serialize output according to media type
        const stdout = (await this.resultToString(queryResult, args.outputType, queryResult.context)).data;
        return { stdout };
    }
}
exports.ActorInitSparql = ActorInitSparql;
//# sourceMappingURL=ActorInitSparql.js.map