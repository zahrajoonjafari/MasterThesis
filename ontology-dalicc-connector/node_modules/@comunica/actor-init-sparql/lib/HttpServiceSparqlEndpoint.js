"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpServiceSparqlEndpoint = void 0;
const cluster = require("cluster");
const http = require("http");
const querystring = require("querystring");
const url = require("url");
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
const asynciterator_1 = require("asynciterator");
const yargs_1 = require("yargs");
const __1 = require("..");
const CliArgsHandlerBase_1 = require("./cli/CliArgsHandlerBase");
const CliArgsHandlerHttp_1 = require("./cli/CliArgsHandlerHttp");
const quad = require('rdf-quad');
/**
 * An HTTP service that exposes a Comunica engine as a SPARQL endpoint.
 */
class HttpServiceSparqlEndpoint {
    constructor(args) {
        var _a, _b, _c;
        args = args !== null && args !== void 0 ? args : {};
        this.context = args.context || {};
        this.timeout = (_a = args.timeout) !== null && _a !== void 0 ? _a : 60000;
        this.port = (_b = args.port) !== null && _b !== void 0 ? _b : 3000;
        this.workers = (_c = args.workers) !== null && _c !== void 0 ? _c : 1;
        this.invalidateCacheBeforeQuery = Boolean(args.invalidateCacheBeforeQuery);
        this.engine = __1.newEngineDynamic(args);
    }
    /**
     * Starts the server
     * @param {string[]} argv The commandline arguments that the script was called with
     * @param {module:stream.internal.Writable} stdout The output stream to log to.
     * @param {module:stream.internal.Writable} stderr The error stream to log errors to.
     * @param {string} moduleRootPath The path to the invoking module.
     * @param {NodeJS.ProcessEnv} env The process env to get constants from.
     * @param {string} defaultConfigPath The path to get the config from if none is defined in the environment.
     * @param {(code: number) => void} exit The callback to invoke to stop the script.
     * @param {ICliArgsHandler[]} cliArgsHandlers Enables manipulation of the CLI arguments and their processing.
     * @return {Promise<void>} A promise that resolves when the server has been started.
     */
    static async runArgsInProcess(argv, stdout, stderr, moduleRootPath, env, defaultConfigPath, exit, cliArgsHandlers = []) {
        const options = await HttpServiceSparqlEndpoint
            .generateConstructorArguments(argv, moduleRootPath, env, defaultConfigPath, stderr, exit, cliArgsHandlers);
        return new Promise(resolve => {
            new HttpServiceSparqlEndpoint(options).run(stdout, stderr)
                .then(resolve)
                .catch(error => {
                stderr.write(error);
                exit(1);
                resolve();
            });
        });
    }
    /**
     * Takes parsed commandline arguments and turns them into an object used in the HttpServiceSparqlEndpoint constructor
     * @param {args: minimist.ParsedArgs} args The commandline arguments that the script was called with
     * @param {string} moduleRootPath The path to the invoking module.
     * @param {NodeJS.ProcessEnv} env The process env to get constants from.
     * @param {string} defaultConfigPath The path to get the config from if none is defined in the environment.
     * @param {ICliArgsHandler[]} cliArgsHandlers Enables manipulation of the CLI arguments and their processing.
     */
    static async generateConstructorArguments(argv, moduleRootPath, env, defaultConfigPath, stderr, exit, cliArgsHandlers) {
        // Populate yargs arguments object
        cliArgsHandlers = [
            new CliArgsHandlerBase_1.CliArgsHandlerBase(),
            new CliArgsHandlerHttp_1.CliArgsHandlerHttp(),
            ...cliArgsHandlers,
        ];
        let argumentsBuilder = yargs_1.default({});
        for (const cliArgsHandler of cliArgsHandlers) {
            argumentsBuilder = cliArgsHandler.populateYargs(argumentsBuilder);
        }
        // Extract raw argument values from parsed yargs object, so that we can handle each of them hereafter
        let args;
        try {
            args = await argumentsBuilder.parse(argv);
        }
        catch (error) {
            stderr.write(`${await argumentsBuilder.getHelp()}\n\n${error.message}\n`);
            return exit(1);
        }
        // Invoke args handlers to process any remaining args
        const context = {};
        try {
            for (const cliArgsHandler of cliArgsHandlers) {
                await cliArgsHandler.handleArgs(args, context);
            }
        }
        catch (error) {
            stderr.write(`${error.message}/n`);
            exit(1);
        }
        const invalidateCacheBeforeQuery = args.invalidateCache;
        const port = args.port;
        const timeout = args.timeout * 1000;
        const workers = args.workers;
        context[context_entries_1.KeysQueryOperation.readOnly] = !args.u;
        const configResourceUrl = env.COMUNICA_CONFIG ? env.COMUNICA_CONFIG : defaultConfigPath;
        return {
            configResourceUrl,
            context,
            invalidateCacheBeforeQuery,
            mainModulePath: moduleRootPath,
            port,
            timeout,
            workers,
        };
    }
    /**
     * Start the HTTP service.
     * @param {module:stream.internal.Writable} stdout The output stream to log to.
     * @param {module:stream.internal.Writable} stderr The error stream to log errors to.
     */
    run(stdout, stderr) {
        if (cluster.isMaster) {
            return this.runMaster(stdout, stderr);
        }
        return this.runWorker(stdout, stderr);
    }
    /**
     * Start the HTTP service as master.
     * @param {module:stream.internal.Writable} stdout The output stream to log to.
     * @param {module:stream.internal.Writable} stderr The error stream to log errors to.
     */
    async runMaster(stdout, stderr) {
        stderr.write(`Server running on http://localhost:${this.port}/sparql\n`);
        // Create workers
        for (let i = 0; i < this.workers; i++) {
            cluster.fork();
        }
        // Attach listeners to each new worker
        cluster.on('listening', worker => {
            // Respawn crashed workers
            worker.once('exit', (code, signal) => {
                if (!worker.exitedAfterDisconnect) {
                    stderr.write(`Worker ${worker.process.pid} died with ${code || signal}. Starting new worker.\n`);
                    cluster.fork();
                }
            });
            // Handle worker timeouts
            let workerTimeout;
            worker.on('message', message => {
                if (message === 'start') {
                    workerTimeout = setTimeout(() => {
                        stderr.write(`Worker ${worker.process.pid} timed out.\n`);
                        worker.send('shutdown');
                        workerTimeout = undefined;
                    }, this.timeout);
                }
                else if (message === 'end' && workerTimeout) {
                    clearTimeout(workerTimeout);
                    workerTimeout = undefined;
                }
            });
        });
        // Disconnect from cluster on SIGINT, so that the process can cleanly terminate
        process.once('SIGINT', () => {
            cluster.disconnect();
        });
    }
    /**
     * Start the HTTP service as worker.
     * @param {module:stream.internal.Writable} stdout The output stream to log to.
     * @param {module:stream.internal.Writable} stderr The error stream to log errors to.
     */
    async runWorker(stdout, stderr) {
        const engine = await this.engine;
        // Determine the allowed media types for requests
        const mediaTypes = await engine.getResultMediaTypes();
        const variants = [];
        for (const type of Object.keys(mediaTypes)) {
            variants.push({ type, quality: mediaTypes[type] });
        }
        // Start the server
        const server = http.createServer(this.handleRequest.bind(this, engine, variants, stdout, stderr));
        server.listen(this.port);
        stderr.write(`Server worker (${process.pid}) running on http://localhost:${this.port}/sparql\n`);
    }
    /**
     * Handles an HTTP request.
     * @param {ActorInitSparql} engine A SPARQL engine.
     * @param {{type: string; quality: number}[]} variants Allowed variants.
     * @param {module:stream.internal.Writable} stdout Output stream.
     * @param {module:stream.internal.Writable} stderr Error output stream.
     * @param {module:http.IncomingMessage} request Request object.
     * @param {module:http.ServerResponse} response Response object.
     */
    async handleRequest(engine, variants, stdout, stderr, request, response) {
        var _a;
        const negotiated = require('negotiate').choose(variants, request)
            .sort((first, second) => second.qts - first.qts);
        const variant = request.headers.accept ? negotiated[0] : null;
        // Require qts strictly larger than 2, as 1 and 2 respectively allow * and */* matching.
        // For qts 0, 1, and 2, we fallback to our built-in media type defaults, for which we pass null.
        const mediaType = variant && variant.qts > 2 ? variant.type : null;
        // Verify the path
        const requestUrl = url.parse((_a = request.url) !== null && _a !== void 0 ? _a : '', true);
        if (requestUrl.pathname === '/' || request.url === '/') {
            stdout.write('[301] Permanently moved. Redirected to /sparql.');
            response.writeHead(301, { 'content-type': HttpServiceSparqlEndpoint.MIME_JSON,
                'Access-Control-Allow-Origin': '*',
                Location: `http://localhost:${this.port}/sparql${requestUrl.search || ''}` });
            response.end(JSON.stringify({ message: 'Queries are accepted on /sparql. Redirected.' }));
            return;
        }
        if (requestUrl.pathname !== '/sparql') {
            stdout.write('[404] Resource not found. Queries are accepted on /sparql.\n');
            response.writeHead(404, { 'content-type': HttpServiceSparqlEndpoint.MIME_JSON,
                'Access-Control-Allow-Origin': '*' });
            response.end(JSON.stringify({ message: 'Resource not found. Queries are accepted on /sparql.' }));
            return;
        }
        if (this.invalidateCacheBeforeQuery) {
            // Invalidate cache
            await engine.invalidateHttpCache();
        }
        // Parse the query, depending on the HTTP method
        let queryBody;
        switch (request.method) {
            case 'POST':
                queryBody = await this.parseBody(request);
                await this.writeQueryResult(engine, stdout, stderr, request, response, queryBody, mediaType, false, false);
                break;
            case 'HEAD':
            case 'GET':
                // eslint-disable-next-line no-case-declarations
                const queryValue = requestUrl.query.query;
                queryBody = queryValue ? { type: 'query', value: queryValue } : undefined;
                // eslint-disable-next-line no-case-declarations
                const headOnly = request.method === 'HEAD';
                await this.writeQueryResult(engine, stdout, stderr, request, response, queryBody, mediaType, headOnly, true);
                break;
            default:
                stdout.write(`[405] ${request.method} to ${request.url}\n`);
                response.writeHead(405, { 'content-type': HttpServiceSparqlEndpoint.MIME_JSON, 'Access-Control-Allow-Origin': '*' });
                response.end(JSON.stringify({ message: 'Incorrect HTTP method' }));
        }
    }
    /**
     * Writes the result of the given SPARQL query.
     * @param {ActorInitSparql} engine A SPARQL engine.
     * @param {module:stream.internal.Writable} stdout Output stream.
     * @param {module:stream.internal.Writable} stderr Error output stream.
     * @param {module:http.IncomingMessage} request Request object.
     * @param {module:http.ServerResponse} response Response object.
     * @param {IQueryBody | undefined} queryBody The query body.
     * @param {string} mediaType The requested response media type.
     * @param {boolean} headOnly If only the header should be written.
     * @param {boolean} readOnly If only data can be read, but not updated. (i.e., if we're in a GET request)
     */
    async writeQueryResult(engine, stdout, stderr, request, response, queryBody, mediaType, headOnly, readOnly) {
        if (!queryBody || !queryBody.value) {
            return this.writeServiceDescription(engine, stdout, stderr, request, response, mediaType, headOnly);
        }
        // Determine context
        let context = this.context;
        if (readOnly) {
            context = Object.assign(Object.assign({}, context), { [context_entries_1.KeysQueryOperation.readOnly]: readOnly });
        }
        let result;
        try {
            result = await engine.query(queryBody.value, context);
            // For update queries, also await the result
            if (result.type === 'update') {
                await result.updateResult;
            }
        }
        catch (error) {
            stdout.write('[400] Bad request\n');
            response.writeHead(400, { 'content-type': HttpServiceSparqlEndpoint.MIME_PLAIN, 'Access-Control-Allow-Origin': '*' });
            response.end(error.message);
            return;
        }
        // Default to SPARQL JSON for bindings and boolean
        if (!mediaType) {
            switch (result.type) {
                case 'quads':
                    mediaType = 'application/trig';
                    break;
                case 'update':
                    mediaType = 'simple';
                    break;
                default:
                    mediaType = 'application/sparql-results+json';
                    break;
            }
        }
        stdout.write(`[200] ${request.method} to ${request.url}\n`);
        stdout.write(`      Requested media type: ${mediaType}\n`);
        stdout.write(`      Received ${queryBody.type} query: ${queryBody.value}\n`);
        response.writeHead(200, { 'content-type': mediaType, 'Access-Control-Allow-Origin': '*' });
        if (headOnly) {
            response.end();
            return;
        }
        // Send message to master process to indicate the start of an execution
        process.send('start');
        // Listen for shutdown events from master for timeouts
        const messageListener = (message) => {
            if (message === 'shutdown') {
                response.end('!TIMED OUT!');
                // eslint-disable-next-line unicorn/no-process-exit
                process.exit(9);
            }
        };
        process.on('message', messageListener);
        let eventEmitter;
        try {
            const { data } = await engine.resultToString(result, mediaType);
            data.on('error', (error) => {
                stdout.write(`[500] Server error in results: ${error.message} \n`);
                response.end('An internal server error occurred.\n');
            });
            data.pipe(response);
            eventEmitter = data;
        }
        catch (_a) {
            stdout.write('[400] Bad request, invalid media type\n');
            response.writeHead(400, { 'content-type': HttpServiceSparqlEndpoint.MIME_PLAIN, 'Access-Control-Allow-Origin': '*' });
            response.end('The response for the given query could not be serialized for the requested media type\n');
        }
        // Send message to master process to indicate the end of an execution
        response.on('close', () => {
            process.removeListener('message', messageListener);
            process.send('end');
        });
        this.stopResponse(response, eventEmitter);
    }
    async writeServiceDescription(engine, stdout, stderr, request, response, mediaType, headOnly) {
        stdout.write(`[200] ${request.method} to ${request.url}\n`);
        stdout.write(`      Requested media type: ${mediaType}\n`);
        stdout.write('      Received query for service description.\n');
        response.writeHead(200, { 'content-type': mediaType, 'Access-Control-Allow-Origin': '*' });
        if (headOnly) {
            response.end();
            return;
        }
        // eslint-disable-next-line id-length
        const s = request.url;
        const sd = 'http://www.w3.org/ns/sparql-service-description#';
        const quads = [
            // Basic metadata
            quad(s, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type', `${sd}Service`),
            quad(s, `${sd}endpoint`, '/sparql'),
            quad(s, `${sd}url`, '/sparql'),
            // Features
            quad(s, `${sd}feature`, `${sd}BasicFederatedQuery`),
            quad(s, `${sd}supportedLanguage`, `${sd}SPARQL10Query`),
            quad(s, `${sd}supportedLanguage`, `${sd}SPARQL11Query`),
        ];
        let eventEmitter;
        try {
            // Append result formats
            const formats = await engine.getResultMediaTypeFormats(core_1.ActionContext(this.context));
            for (const format in formats) {
                quads.push(quad(s, `${sd}resultFormat`, formats[format]));
            }
            // Flush results
            const { data } = await engine.resultToString({
                type: 'quads',
                quadStream: new asynciterator_1.ArrayIterator(quads),
            }, mediaType);
            data.on('error', (error) => {
                stdout.write(`[500] Server error in results: ${error.message} \n`);
                response.end('An internal server error occurred.\n');
            });
            data.pipe(response);
            eventEmitter = data;
        }
        catch (_a) {
            stdout.write('[400] Bad request, invalid media type\n');
            response.writeHead(400, { 'content-type': HttpServiceSparqlEndpoint.MIME_PLAIN, 'Access-Control-Allow-Origin': '*' });
            response.end('The response for the given query could not be serialized for the requested media type\n');
            return;
        }
        this.stopResponse(response, eventEmitter);
    }
    /**
     * Stop after timeout or if the connection is terminated
     * @param {module:http.ServerResponse} response Response object.
     * @param {NodeJS.ReadableStream} eventEmitter Query result stream.
     */
    stopResponse(response, eventEmitter) {
        response.on('close', killClient);
        function killClient() {
            if (eventEmitter) {
                // Remove all listeners so we are sure no more write calls are made
                eventEmitter.removeAllListeners();
                eventEmitter.emit('end');
            }
            try {
                response.end();
            }
            catch (_a) {
                // Do nothing
            }
        }
    }
    /**
     * Parses the body of a SPARQL POST request
     * @param {module:http.IncomingMessage} request Request object.
     * @return {Promise<IQueryBody>} A promise resolving to a query body object.
     */
    parseBody(request) {
        return new Promise((resolve, reject) => {
            let body = '';
            request.setEncoding('utf8');
            request.on('error', reject);
            request.on('data', chunk => {
                body += chunk;
            });
            request.on('end', () => {
                const contentType = request.headers['content-type'];
                if (contentType) {
                    if (contentType.includes('application/sparql-query')) {
                        return resolve({ type: 'query', value: body });
                    }
                    if (contentType.includes('application/sparql-update')) {
                        return resolve({ type: 'update', value: body });
                    }
                    if (contentType.includes('application/x-www-form-urlencoded')) {
                        const bodyStructure = querystring.parse(body);
                        if (bodyStructure.query) {
                            return resolve({ type: 'query', value: bodyStructure.query });
                        }
                        if (bodyStructure.update) {
                            return resolve({ type: 'update', value: bodyStructure.update });
                        }
                    }
                }
                reject(new Error(`Invalid POST body received, query type could not be determined`));
            });
        });
    }
}
exports.HttpServiceSparqlEndpoint = HttpServiceSparqlEndpoint;
HttpServiceSparqlEndpoint.MIME_PLAIN = 'text/plain';
HttpServiceSparqlEndpoint.MIME_JSON = 'application/json';
//# sourceMappingURL=HttpServiceSparqlEndpoint.js.map