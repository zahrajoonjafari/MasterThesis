{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;\n/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nvar _assert_1 = require(\"@noble/hashes/_assert\");\nvar pbkdf2_1 = require(\"@noble/hashes/pbkdf2\");\nvar sha256_1 = require(\"@noble/hashes/sha256\");\nvar sha512_1 = require(\"@noble/hashes/sha512\");\nvar utils_1 = require(\"@noble/hashes/utils\");\nvar base_1 = require(\"@scure/base\");\n// Japanese wordlist\nvar isJapanese = function isJapanese(wordlist) {\n  return wordlist[0] === \"\\u3042\\u3044\\u3053\\u304F\\u3057\\u3093\";\n};\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\nfunction nfkd(str) {\n  if (typeof str !== 'string') throw new TypeError(\"Invalid mnemonic type: \".concat(typeof str));\n  return str.normalize('NFKD');\n}\nfunction normalize(str) {\n  var norm = nfkd(str);\n  var words = norm.split(' ');\n  if (![12, 15, 18, 21, 24].includes(words.length)) throw new Error('Invalid mnemonic');\n  return {\n    nfkd: norm,\n    words: words\n  };\n}\nfunction assertEntropy(entropy) {\n  _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nfunction generateMnemonic(wordlist) {\n  var strength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 128;\n  _assert_1.default.number(strength);\n  if (strength % 32 !== 0 || strength > 256) throw new TypeError('Invalid entropy');\n  return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);\n}\nexports.generateMnemonic = generateMnemonic;\nvar calcChecksum = function calcChecksum(entropy) {\n  // Checksum is ent.length/4 bits long\n  var bitsLeft = 8 - entropy.length / 4;\n  // Zero rightmost \"bitsLeft\" bits in byte\n  // For example: bitsLeft=4 val=10111101 -> 10110000\n  return new Uint8Array([(0, sha256_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n  if (!Array.isArray(wordlist) || wordlist.length !== Math.pow(2, 11) || typeof wordlist[0] !== 'string') throw new Error('Worlist: expected array of 2048 strings');\n  wordlist.forEach(function (i) {\n    if (typeof i !== 'string') throw new Error(\"Wordlist: non-string element: \".concat(i));\n  });\n  return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  var _normalize = normalize(mnemonic),\n    words = _normalize.words;\n  var entropy = getCoder(wordlist).decode(words);\n  assertEntropy(entropy);\n  return entropy;\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nfunction entropyToMnemonic(entropy, wordlist) {\n  assertEntropy(entropy);\n  var words = getCoder(wordlist).encode(entropy);\n  return words.join(isJapanese(wordlist) ? \"\\u3000\" : ' ');\n}\nexports.entropyToMnemonic = entropyToMnemonic;\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */\nfunction validateMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\nexports.validateMnemonic = validateMnemonic;\nvar salt = function salt(passphrase) {\n  return nfkd(\"mnemonic\".concat(passphrase));\n};\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nfunction mnemonicToSeed(mnemonic) {\n  var passphrase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), {\n    c: 2048,\n    dkLen: 64\n  });\n}\nexports.mnemonicToSeed = mnemonicToSeed;\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nfunction mnemonicToSeedSync(mnemonic) {\n  var passphrase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), {\n    c: 2048,\n    dkLen: 64\n  });\n}\nexports.mnemonicToSeedSync = mnemonicToSeedSync;","map":null,"metadata":{},"sourceType":"script"}