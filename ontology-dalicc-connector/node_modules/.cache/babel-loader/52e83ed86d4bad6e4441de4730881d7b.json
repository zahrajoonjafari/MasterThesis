{"ast":null,"code":"//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\n\nvar events = require('events');\nvar precond = require('precond');\nvar util = require('util');\nvar Backoff = require('./backoff');\nvar FibonacciBackoffStrategy = require('./strategy/fibonacci');\n\n// Wraps a function to be called in a backoff loop.\nfunction FunctionCall(fn, args, callback) {\n  events.EventEmitter.call(this);\n  precond.checkIsFunction(fn, 'Expected fn to be a function.');\n  precond.checkIsArray(args, 'Expected args to be an array.');\n  precond.checkIsFunction(callback, 'Expected callback to be a function.');\n  this.function_ = fn;\n  this.arguments_ = args;\n  this.callback_ = callback;\n  this.lastResult_ = [];\n  this.numRetries_ = 0;\n  this.backoff_ = null;\n  this.strategy_ = null;\n  this.failAfter_ = -1;\n  this.retryPredicate_ = FunctionCall.DEFAULT_RETRY_PREDICATE_;\n  this.state_ = FunctionCall.State_.PENDING;\n}\nutil.inherits(FunctionCall, events.EventEmitter);\n\n// States in which the call can be.\nFunctionCall.State_ = {\n  // Call isn't started yet.\n  PENDING: 0,\n  // Call is in progress.\n  RUNNING: 1,\n  // Call completed successfully which means that either the wrapped function\n  // returned successfully or the maximal number of backoffs was reached.\n  COMPLETED: 2,\n  // The call was aborted.\n  ABORTED: 3\n};\n\n// The default retry predicate which considers any error as retriable.\nFunctionCall.DEFAULT_RETRY_PREDICATE_ = function (err) {\n  return true;\n};\n\n// Checks whether the call is pending.\nFunctionCall.prototype.isPending = function () {\n  return this.state_ == FunctionCall.State_.PENDING;\n};\n\n// Checks whether the call is in progress.\nFunctionCall.prototype.isRunning = function () {\n  return this.state_ == FunctionCall.State_.RUNNING;\n};\n\n// Checks whether the call is completed.\nFunctionCall.prototype.isCompleted = function () {\n  return this.state_ == FunctionCall.State_.COMPLETED;\n};\n\n// Checks whether the call is aborted.\nFunctionCall.prototype.isAborted = function () {\n  return this.state_ == FunctionCall.State_.ABORTED;\n};\n\n// Sets the backoff strategy to use. Can only be called before the call is\n// started otherwise an exception will be thrown.\nFunctionCall.prototype.setStrategy = function (strategy) {\n  precond.checkState(this.isPending(), 'FunctionCall in progress.');\n  this.strategy_ = strategy;\n  return this; // Return this for chaining.\n};\n\n// Sets the predicate which will be used to determine whether the errors\n// returned from the wrapped function should be retried or not, e.g. a\n// network error would be retriable while a type error would stop the\n// function call.\nFunctionCall.prototype.retryIf = function (retryPredicate) {\n  precond.checkState(this.isPending(), 'FunctionCall in progress.');\n  this.retryPredicate_ = retryPredicate;\n  return this;\n};\n\n// Returns all intermediary results returned by the wrapped function since\n// the initial call.\nFunctionCall.prototype.getLastResult = function () {\n  return this.lastResult_.concat();\n};\n\n// Returns the number of times the wrapped function call was retried.\nFunctionCall.prototype.getNumRetries = function () {\n  return this.numRetries_;\n};\n\n// Sets the backoff limit.\nFunctionCall.prototype.failAfter = function (maxNumberOfRetry) {\n  precond.checkState(this.isPending(), 'FunctionCall in progress.');\n  this.failAfter_ = maxNumberOfRetry;\n  return this; // Return this for chaining.\n};\n\n// Aborts the call.\nFunctionCall.prototype.abort = function () {\n  if (this.isCompleted() || this.isAborted()) {\n    return;\n  }\n  if (this.isRunning()) {\n    this.backoff_.reset();\n  }\n  this.state_ = FunctionCall.State_.ABORTED;\n  this.lastResult_ = [new Error('Backoff aborted.')];\n  this.emit('abort');\n  this.doCallback_();\n};\n\n// Initiates the call to the wrapped function. Accepts an optional factory\n// function used to create the backoff instance; used when testing.\nFunctionCall.prototype.start = function (backoffFactory) {\n  precond.checkState(!this.isAborted(), 'FunctionCall is aborted.');\n  precond.checkState(this.isPending(), 'FunctionCall already started.');\n  var strategy = this.strategy_ || new FibonacciBackoffStrategy();\n  this.backoff_ = backoffFactory ? backoffFactory(strategy) : new Backoff(strategy);\n  this.backoff_.on('ready', this.doCall_.bind(this, true /* isRetry */));\n  this.backoff_.on('fail', this.doCallback_.bind(this));\n  this.backoff_.on('backoff', this.handleBackoff_.bind(this));\n  if (this.failAfter_ > 0) {\n    this.backoff_.failAfter(this.failAfter_);\n  }\n  this.state_ = FunctionCall.State_.RUNNING;\n  this.doCall_(false /* isRetry */);\n};\n\n// Calls the wrapped function.\nFunctionCall.prototype.doCall_ = function (isRetry) {\n  if (isRetry) {\n    this.numRetries_++;\n  }\n  var eventArgs = ['call'].concat(this.arguments_);\n  events.EventEmitter.prototype.emit.apply(this, eventArgs);\n  var callback = this.handleFunctionCallback_.bind(this);\n  this.function_.apply(null, this.arguments_.concat(callback));\n};\n\n// Calls the wrapped function's callback with the last result returned by the\n// wrapped function.\nFunctionCall.prototype.doCallback_ = function () {\n  this.callback_.apply(null, this.lastResult_);\n};\n\n// Handles wrapped function's completion. This method acts as a replacement\n// for the original callback function.\nFunctionCall.prototype.handleFunctionCallback_ = function () {\n  if (this.isAborted()) {\n    return;\n  }\n  var args = Array.prototype.slice.call(arguments);\n  this.lastResult_ = args; // Save last callback arguments.\n  events.EventEmitter.prototype.emit.apply(this, ['callback'].concat(args));\n  var err = args[0];\n  if (err && this.retryPredicate_(err)) {\n    this.backoff_.backoff(err);\n  } else {\n    this.state_ = FunctionCall.State_.COMPLETED;\n    this.doCallback_();\n  }\n};\n\n// Handles the backoff event by reemitting it.\nFunctionCall.prototype.handleBackoff_ = function (number, delay, err) {\n  this.emit('backoff', number, delay, err);\n};\nmodule.exports = FunctionCall;","map":null,"metadata":{},"sourceType":"script"}