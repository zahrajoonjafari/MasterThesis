{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;\nvar nacl = __importStar(require(\"tweetnacl\"));\nvar naclUtil = __importStar(require(\"tweetnacl-util\"));\nvar utils_1 = require(\"./utils\");\n/**\n * Encrypt a message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nfunction encrypt(_ref) {\n  var publicKey = _ref.publicKey,\n    data = _ref.data,\n    version = _ref.version;\n  if (utils_1.isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (utils_1.isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (utils_1.isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n  switch (version) {\n    case 'x25519-xsalsa20-poly1305':\n      {\n        if (typeof data !== 'string') {\n          throw new Error('Message data must be given as a string');\n        }\n        // generate ephemeral keypair\n        var ephemeralKeyPair = nacl.box.keyPair();\n        // assemble encryption parameters - from string to UInt8\n        var pubKeyUInt8Array;\n        try {\n          pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);\n        } catch (err) {\n          throw new Error('Bad public key');\n        }\n        var msgParamsUInt8Array = naclUtil.decodeUTF8(data);\n        var nonce = nacl.randomBytes(nacl.box.nonceLength);\n        // encrypt\n        var encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);\n        // handle encrypted data\n        var output = {\n          version: 'x25519-xsalsa20-poly1305',\n          nonce: naclUtil.encodeBase64(nonce),\n          ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n          ciphertext: naclUtil.encodeBase64(encryptedMessage)\n        };\n        // return encrypted msg data\n        return output;\n      }\n    default:\n      throw new Error('Encryption type/version not supported');\n  }\n}\nexports.encrypt = encrypt;\n/**\n * Encrypt a message in a way that obscures the message length.\n *\n * The message is padded to a multiple of 2048 before being encrypted so that the length of the\n * resulting encrypted message can't be used to guess the exact length of the original message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nfunction encryptSafely(_ref2) {\n  var publicKey = _ref2.publicKey,\n    data = _ref2.data,\n    version = _ref2.version;\n  if (utils_1.isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (utils_1.isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (utils_1.isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n  var DEFAULT_PADDING_LENGTH = Math.pow(2, 11);\n  var NACL_EXTRA_BYTES = 16;\n  if (typeof data === 'object' && 'toJSON' in data) {\n    // remove toJSON attack vector\n    // TODO, check all possible children\n    throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\n  }\n  // add padding\n  var dataWithPadding = {\n    data: data,\n    padding: ''\n  };\n  // calculate padding\n  var dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\n  var modVal = dataLength % DEFAULT_PADDING_LENGTH;\n  var padLength = 0;\n  // Only pad if necessary\n  if (modVal > 0) {\n    padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n  }\n\n  dataWithPadding.padding = '0'.repeat(padLength);\n  var paddedMessage = JSON.stringify(dataWithPadding);\n  return encrypt({\n    publicKey: publicKey,\n    data: paddedMessage,\n    version: version\n  });\n}\nexports.encryptSafely = encryptSafely;\n/**\n * Decrypt a message.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nfunction decrypt(_ref3) {\n  var encryptedData = _ref3.encryptedData,\n    privateKey = _ref3.privateKey;\n  if (utils_1.isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (utils_1.isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n  switch (encryptedData.version) {\n    case 'x25519-xsalsa20-poly1305':\n      {\n        // string to buffer to UInt8Array\n        var recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);\n        var recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey;\n        // assemble decryption parameters\n        var nonce = naclUtil.decodeBase64(encryptedData.nonce);\n        var ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);\n        var ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey);\n        // decrypt\n        var decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey);\n        // return decrypted msg data\n        var output;\n        try {\n          output = naclUtil.encodeUTF8(decryptedMessage);\n        } catch (err) {\n          throw new Error('Decryption failed.');\n        }\n        if (output) {\n          return output;\n        }\n        throw new Error('Decryption failed.');\n      }\n    default:\n      throw new Error('Encryption type/version not supported.');\n  }\n}\nexports.decrypt = decrypt;\n/**\n * Decrypt a message that has been encrypted using `encryptSafely`.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nfunction decryptSafely(_ref4) {\n  var encryptedData = _ref4.encryptedData,\n    privateKey = _ref4.privateKey;\n  if (utils_1.isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (utils_1.isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n  var dataWithPadding = JSON.parse(decrypt({\n    encryptedData: encryptedData,\n    privateKey: privateKey\n  }));\n  return dataWithPadding.data;\n}\nexports.decryptSafely = decryptSafely;\n/**\n * Get the encryption public key for the given key.\n *\n * @param privateKey - The private key to generate the encryption public key with.\n * @returns The encryption public key.\n */\nfunction getEncryptionPublicKey(privateKey) {\n  var privateKeyUint8Array = nacl_decodeHex(privateKey);\n  var encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n  return naclUtil.encodeBase64(encryptionPublicKey);\n}\nexports.getEncryptionPublicKey = getEncryptionPublicKey;\n/**\n * Convert a hex string to the UInt8Array format used by nacl.\n *\n * @param msgHex - The string to convert.\n * @returns The converted string.\n */\nfunction nacl_decodeHex(msgHex) {\n  var msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return naclUtil.decodeBase64(msgBase64);\n}","map":null,"metadata":{},"sourceType":"script"}