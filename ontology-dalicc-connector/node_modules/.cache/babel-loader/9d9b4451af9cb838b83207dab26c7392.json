{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/sima/Desktop/finalMaster/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/sima/Desktop/finalMaster/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar _HDWalletProvider_wallets, _HDWalletProvider_addresses;\nvar bip39_1 = require(\"ethereum-cryptography/bip39\");\nvar english_1 = require(\"ethereum-cryptography/bip39/wordlists/english\");\nvar EthUtil = __importStar(require(\"ethereumjs-util\"));\nvar tx_1 = require(\"@ethereumjs/tx\");\nvar common_1 = __importDefault(require(\"@ethereumjs/common\"));\nvar web3_provider_engine_1 = __importDefault(require(\"web3-provider-engine\"));\n// @ts-ignore - web3-provider-engine doesn't have declaration files for these subproviders\nvar filters_1 = __importDefault(require(\"web3-provider-engine/subproviders/filters\"));\n// @ts-ignore\nvar nonce_tracker_1 = __importDefault(require(\"web3-provider-engine/subproviders/nonce-tracker\"));\n// @ts-ignore\nvar hooked_wallet_1 = __importDefault(require(\"web3-provider-engine/subproviders/hooked-wallet\"));\n// @ts-ignore\nvar provider_1 = __importDefault(require(\"web3-provider-engine/subproviders/provider\"));\n// @ts-ignore\nvar rpc_1 = __importDefault(require(\"web3-provider-engine/subproviders/rpc\"));\n// @ts-ignore\nvar websocket_1 = __importDefault(require(\"web3-provider-engine/subproviders/websocket\"));\nvar url_1 = __importDefault(require(\"url\"));\nvar getOptions_1 = require(\"./constructor/getOptions\");\nvar getPrivateKeys_1 = require(\"./constructor/getPrivateKeys\");\nvar getMnemonic_1 = require(\"./constructor/getMnemonic\");\nvar eth_sig_util_1 = require(\"@metamask/eth-sig-util\");\nvar hdwallet_1 = require(\"@truffle/hdwallet\");\n// Important: do not use debug module. Reason: https://github.com/trufflesuite/truffle/issues/2374#issuecomment-536109086\n// This line shares nonce state across multiple provider instances. Necessary\n// because within truffle the wallet is repeatedly newed if it's declared in the config within a\n// function, resetting nonce from tx to tx. An instance can opt out\n// of this behavior by passing `shareNonce=false` to the constructor.\n// See issue #65 for more\nvar singletonNonceSubProvider = new nonce_tracker_1.default();\nvar HDWalletProvider = /*#__PURE__*/function () {\n  function HDWalletProvider() {\n    _classCallCheck(this, HDWalletProvider);\n    _HDWalletProvider_wallets.set(this, void 0);\n    _HDWalletProvider_addresses.set(this, void 0);\n    var _a = (0, getOptions_1.getOptions).apply(void 0, arguments),\n      provider = _a.provider,\n      url = _a.url,\n      providerOrUrl = _a.providerOrUrl,\n      _a$addressIndex = _a.addressIndex,\n      addressIndex = _a$addressIndex === void 0 ? 0 : _a$addressIndex,\n      _a$numberOfAddresses = _a.numberOfAddresses,\n      numberOfAddresses = _a$numberOfAddresses === void 0 ? 10 : _a$numberOfAddresses,\n      _a$shareNonce = _a.shareNonce,\n      shareNonce = _a$shareNonce === void 0 ? true : _a$shareNonce,\n      _a$derivationPath = _a.derivationPath,\n      derivationPath = _a$derivationPath === void 0 ? \"m/44'/60'/0'/0/\" : _a$derivationPath,\n      _a$pollingInterval = _a.pollingInterval,\n      pollingInterval = _a$pollingInterval === void 0 ? 4000 : _a$pollingInterval,\n      chainId = _a.chainId,\n      _a$chainSettings = _a.chainSettings,\n      chainSettings = _a$chainSettings === void 0 ? {} : _a$chainSettings,\n      signingAuthority = __rest(_a, [\"provider\", \"url\", \"providerOrUrl\", \"addressIndex\", \"numberOfAddresses\", \"shareNonce\", \"derivationPath\", \"pollingInterval\", \"chainId\", \"chainSettings\"]);\n    var mnemonic = (0, getMnemonic_1.getMnemonic)(signingAuthority);\n    var privateKeys = (0, getPrivateKeys_1.getPrivateKeys)(signingAuthority);\n    this.walletHdpath = derivationPath;\n    __classPrivateFieldSet(this, _HDWalletProvider_wallets, {}, \"f\");\n    __classPrivateFieldSet(this, _HDWalletProvider_addresses, [], \"f\");\n    this.chainSettings = chainSettings;\n    this.engine = new web3_provider_engine_1.default({\n      pollingInterval: pollingInterval\n    });\n    var providerToUse;\n    if (HDWalletProvider.isValidProvider(provider)) {\n      providerToUse = provider;\n    } else if (HDWalletProvider.isValidProvider(url)) {\n      providerToUse = url;\n    } else {\n      providerToUse = providerOrUrl;\n    }\n    if (!HDWalletProvider.isValidProvider(providerToUse)) {\n      throw new Error([\"No provider or an invalid provider was specified: '\".concat(providerToUse, \"'\"), \"Please specify a valid provider or URL, using the http, https, \" + \"ws, or wss protocol.\", \"\"].join(\"\\n\"));\n    }\n    if (mnemonic && mnemonic.phrase) {\n      this.checkBIP39Mnemonic(Object.assign(Object.assign({}, mnemonic), {\n        addressIndex: addressIndex,\n        numberOfAddresses: numberOfAddresses\n      }));\n    } else if (privateKeys) {\n      var options = Object.assign({}, {\n        privateKeys: privateKeys\n      }, {\n        addressIndex: addressIndex\n      });\n      this.ethUtilValidation(options);\n    } // no need to handle else case here, since matchesNewOptions() covers it\n    if (__classPrivateFieldGet(this, _HDWalletProvider_addresses, \"f\").length === 0) {\n      throw new Error(\"Could not create addresses from your mnemonic or private key(s). \" + \"Please check that your inputs are correct.\");\n    }\n    var tmpAccounts = __classPrivateFieldGet(this, _HDWalletProvider_addresses, \"f\");\n    var tmpWallets = __classPrivateFieldGet(this, _HDWalletProvider_wallets, \"f\");\n    // if user supplied the chain id, use that - otherwise fetch it\n    if (typeof chainId !== \"undefined\" || chainSettings && typeof chainSettings.chainId !== \"undefined\") {\n      this.chainId = chainId || chainSettings.chainId;\n      this.initialized = Promise.resolve();\n    } else {\n      this.initialized = this.initialize();\n    }\n    // EIP155 compliant transactions are enabled for hardforks later\n    // than or equal to \"spurious dragon\"\n    this.hardfork = chainSettings && chainSettings.hardfork ? chainSettings.hardfork : \"london\";\n    var self = this;\n    this.engine.addProvider(new hooked_wallet_1.default({\n      getAccounts: function getAccounts(cb) {\n        cb(null, tmpAccounts);\n      },\n      getPrivateKey: function getPrivateKey(address, cb) {\n        if (!tmpWallets[address]) {\n          cb(\"Account not found\");\n          return;\n        } else {\n          cb(null, tmpWallets[address].toString(\"hex\"));\n        }\n      },\n      signTransaction: function signTransaction(txParams, cb) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          var pkey, from, chain, KNOWN_CHAIN_IDS, txOptions, hasEip1559, tx, signedTx, rawTx;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return self.initialized;\n              case 2:\n                // we need to rename the 'gas' field\n                txParams.gasLimit = txParams.gas;\n                delete txParams.gas;\n                from = txParams.from.toLowerCase();\n                if (!tmpWallets[from]) {\n                  _context.next = 9;\n                  break;\n                }\n                pkey = tmpWallets[from];\n                _context.next = 11;\n                break;\n              case 9:\n                cb(\"Account not found\");\n                return _context.abrupt(\"return\");\n              case 11:\n                chain = self.chainId;\n                KNOWN_CHAIN_IDS = new Set([1, 3, 4, 5, 42]);\n                if (typeof chain !== \"undefined\" && KNOWN_CHAIN_IDS.has(chain)) {\n                  txOptions = {\n                    common: new common_1.default({\n                      chain: chain,\n                      hardfork: self.hardfork\n                    })\n                  };\n                } else if (typeof chain !== \"undefined\") {\n                  txOptions = {\n                    common: common_1.default.forCustomChain(1, {\n                      name: \"custom chain\",\n                      chainId: chain\n                    }, self.hardfork)\n                  };\n                }\n                // Taken from https://github.com/ethers-io/ethers.js/blob/2a7ce0e72a1e0c9469e10392b0329e75e341cf18/packages/abstract-signer/src.ts/index.ts#L215\n                hasEip1559 = txParams.maxFeePerGas !== undefined || txParams.maxPriorityFeePerGas !== undefined;\n                tx = hasEip1559 ? tx_1.FeeMarketEIP1559Transaction.fromTxData(txParams, txOptions) : tx_1.Transaction.fromTxData(txParams, txOptions);\n                signedTx = tx.sign(pkey);\n                rawTx = \"0x\".concat(signedTx.serialize().toString(\"hex\"));\n                cb(null, rawTx);\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee);\n        }));\n      },\n      signMessage: function signMessage(_ref, cb) {\n        var data = _ref.data,\n          from = _ref.from;\n        var dataIfExists = data;\n        if (!dataIfExists) {\n          cb(\"No data to sign\");\n          return;\n        }\n        if (!tmpWallets[from]) {\n          cb(\"Account not found\");\n          return;\n        }\n        var pkey = tmpWallets[from];\n        var dataBuff = EthUtil.toBuffer(dataIfExists);\n        var msgHashBuff = EthUtil.hashPersonalMessage(dataBuff);\n        var sig = EthUtil.ecsign(msgHashBuff, pkey);\n        var rpcSig = EthUtil.toRpcSig(sig.v, sig.r, sig.s);\n        cb(null, rpcSig);\n      },\n      signPersonalMessage: function signPersonalMessage() {\n        this.signMessage.apply(this, arguments);\n      },\n      signTypedMessage: function signTypedMessage(_ref2, cb) {\n        var data = _ref2.data,\n          from = _ref2.from;\n        if (!data) {\n          cb(\"No data to sign\");\n          return;\n        }\n        // convert address to lowercase in case it is in checksum format\n        var fromAddress = from.toLowerCase();\n        if (!tmpWallets[fromAddress]) {\n          cb(\"Account not found\");\n          return;\n        }\n        var signature = (0, eth_sig_util_1.signTypedData)({\n          data: JSON.parse(data),\n          privateKey: tmpWallets[fromAddress],\n          version: eth_sig_util_1.SignTypedDataVersion.V4\n        });\n        cb(null, signature);\n      }\n    }));\n    !shareNonce ? this.engine.addProvider(new nonce_tracker_1.default()) : this.engine.addProvider(singletonNonceSubProvider);\n    this.engine.addProvider(new filters_1.default());\n    if (typeof providerToUse === \"string\") {\n      var _url = providerToUse;\n      var providerProtocol = (url_1.default.parse(_url).protocol || \"http:\").toLowerCase();\n      switch (providerProtocol) {\n        case \"ws:\":\n        case \"wss:\":\n          this.engine.addProvider(new websocket_1.default({\n            rpcUrl: _url\n          }));\n          break;\n        default:\n          this.engine.addProvider(new rpc_1.default({\n            rpcUrl: _url\n          }));\n      }\n    } else {\n      this.engine.addProvider(new provider_1.default(providerToUse));\n    }\n    // Required by the provider engine.\n    this.engine.start();\n  }\n  _createClass(HDWalletProvider, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var _this = this;\n      return new Promise(function (resolve, reject) {\n        _this.engine.sendAsync({\n          jsonrpc: \"2.0\",\n          id: Date.now(),\n          method: \"eth_chainId\",\n          params: []\n        },\n        // @ts-ignore - the type doesn't take into account the possibility\n        // that response.error could be a thing\n        function (error, response) {\n          if (error) {\n            reject(error);\n            return;\n          } else if (response.error) {\n            reject(response.error);\n            return;\n          }\n          if (isNaN(parseInt(response.result, 16))) {\n            var message = \"When requesting the chain id from the node, it\" + \"returned the malformed result \".concat(response.result, \".\");\n            throw new Error(message);\n          }\n          _this.chainId = parseInt(response.result, 16);\n          resolve();\n        });\n      });\n    } // private helper to check if given mnemonic uses BIP39 passphrase protection\n  }, {\n    key: \"checkBIP39Mnemonic\",\n    value: function checkBIP39Mnemonic(_ref3) {\n      var addressIndex = _ref3.addressIndex,\n        numberOfAddresses = _ref3.numberOfAddresses,\n        phrase = _ref3.phrase,\n        password = _ref3.password;\n      if (!(0, bip39_1.validateMnemonic)(phrase, english_1.wordlist)) {\n        throw new Error(\"Mnemonic invalid or undefined\");\n      }\n      var hdwallet = (0, hdwallet_1.createAccountGeneratorFromSeedAndPath)((0, bip39_1.mnemonicToSeedSync)(phrase, password), this.walletHdpath.replace(/\\/$/, \"\").split(\"/\"));\n      // crank the addresses out\n      for (var i = addressIndex; i < addressIndex + numberOfAddresses; i++) {\n        var wallet = hdwallet(i);\n        var addr = \"0x\".concat(Buffer.from((0, hdwallet_1.uncompressedPublicKeyToAddress)(wallet.publicKey)).toString(\"hex\"));\n        __classPrivateFieldGet(this, _HDWalletProvider_addresses, \"f\").push(addr);\n        __classPrivateFieldGet(this, _HDWalletProvider_wallets, \"f\")[addr] = wallet.privateKey;\n      }\n    } // private helper leveraging ethUtils to populate wallets/addresses\n  }, {\n    key: \"ethUtilValidation\",\n    value: function ethUtilValidation(_ref4) {\n      var addressIndex = _ref4.addressIndex,\n        privateKeys = _ref4.privateKeys;\n      // crank the addresses out\n      for (var i = addressIndex; i < privateKeys.length; i++) {\n        var privateKey = Buffer.from(privateKeys[i].replace(\"0x\", \"\"), \"hex\");\n        if (EthUtil.isValidPrivate(privateKey)) {\n          var wallet = EthUtil.privateToAddress(privateKey);\n          var address = \"0x\".concat(wallet.toString(\"hex\"));\n          __classPrivateFieldGet(this, _HDWalletProvider_addresses, \"f\").push(address);\n          __classPrivateFieldGet(this, _HDWalletProvider_wallets, \"f\")[address] = privateKey;\n        }\n      }\n    }\n  }, {\n    key: \"send\",\n    value: function send(payload,\n    // @ts-ignore we patch this method so it doesn't conform to type\n    callback) {\n      var _this2 = this;\n      this.initialized.then(function () {\n        _this2.engine.sendAsync(payload, callback);\n      });\n    }\n  }, {\n    key: \"sendAsync\",\n    value: function sendAsync(payload, callback) {\n      var _this3 = this;\n      this.initialized.then(function () {\n        _this3.engine.sendAsync(payload, callback);\n      });\n    }\n  }, {\n    key: \"getAddress\",\n    value: function getAddress(idx) {\n      if (!idx) {\n        return __classPrivateFieldGet(this, _HDWalletProvider_addresses, \"f\")[0];\n      } else {\n        return __classPrivateFieldGet(this, _HDWalletProvider_addresses, \"f\")[idx];\n      }\n    }\n  }, {\n    key: \"getAddresses\",\n    value: function getAddresses() {\n      return __classPrivateFieldGet(this, _HDWalletProvider_addresses, \"f\");\n    }\n  }], [{\n    key: \"isValidProvider\",\n    value: function isValidProvider(provider) {\n      if (!provider) return false;\n      if (typeof provider === \"string\") {\n        var validProtocols = [\"http:\", \"https:\", \"ws:\", \"wss:\"];\n        var url = url_1.default.parse(provider.toLowerCase());\n        return !!(validProtocols.includes(url.protocol || \"\") && url.slashes);\n      } else if (\"request\" in provider) {\n        // provider is an 1193 provider\n        return true;\n      } else if (\"send\" in provider) {\n        // provider is a \"legacy\" provider\n        return true;\n      }\n      return false;\n    }\n  }]);\n  return HDWalletProvider;\n}();\n_HDWalletProvider_wallets = new WeakMap(), _HDWalletProvider_addresses = new WeakMap();\nmodule.exports = HDWalletProvider;","map":null,"metadata":{},"sourceType":"script"}