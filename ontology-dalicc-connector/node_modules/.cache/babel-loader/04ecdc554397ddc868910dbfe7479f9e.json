{"ast":null,"code":"var _slicedToArray = require(\"/home/sima/Desktop/finalMaster/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar _classCallCheck = require(\"/home/sima/Desktop/finalMaster/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/sima/Desktop/finalMaster/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/home/sima/Desktop/finalMaster/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/sima/Desktop/finalMaster/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/sima/Desktop/finalMaster/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _assertThisInitialized = require(\"/home/sima/Desktop/finalMaster/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\nvar Backoff = require('backoff');\nvar EventEmitter = require('events');\nvar inherits = require('util').inherits;\nvar WebSocket = global.WebSocket || require('ws');\nvar Subprovider = require('./subprovider');\nvar createPayload = require('../util/create-payload');\nvar WebsocketSubprovider = /*#__PURE__*/function (_Subprovider) {\n  \"use strict\";\n\n  _inherits(WebsocketSubprovider, _Subprovider);\n  function WebsocketSubprovider(_ref) {\n    var _this;\n    var rpcUrl = _ref.rpcUrl,\n      debug = _ref.debug,\n      origin = _ref.origin;\n    _classCallCheck(this, WebsocketSubprovider);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebsocketSubprovider).call(this));\n\n    // inherit from EventEmitter\n    EventEmitter.call(_assertThisInitialized(_assertThisInitialized(_this)));\n    Object.defineProperties(_assertThisInitialized(_assertThisInitialized(_this)), {\n      _backoff: {\n        value: Backoff.exponential({\n          randomisationFactor: 0.2,\n          maxDelay: 5000\n        })\n      },\n      _connectTime: {\n        value: null,\n        writable: true\n      },\n      _log: {\n        value: debug ? function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          return console.info.apply(console, ['[WSProvider]'].concat(args));\n        } : function () {}\n      },\n      _origin: {\n        value: origin\n      },\n      _pendingRequests: {\n        value: new Map()\n      },\n      _socket: {\n        value: null,\n        writable: true\n      },\n      _unhandledRequests: {\n        value: []\n      },\n      _url: {\n        value: rpcUrl\n      }\n    });\n    _this._handleSocketClose = _this._handleSocketClose.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._handleSocketMessage = _this._handleSocketMessage.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._handleSocketOpen = _this._handleSocketOpen.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    // Called when a backoff timeout has finished. Time to try reconnecting.\n    _this._backoff.on('ready', function () {\n      _this._openSocket();\n    });\n    _this._openSocket();\n    return _this;\n  }\n  _createClass(WebsocketSubprovider, [{\n    key: \"handleRequest\",\n    value: function handleRequest(payload, next, end) {\n      if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n        this._unhandledRequests.push(Array.from(arguments));\n        this._log('Socket not open. Request queued.');\n        return;\n      }\n      this._pendingRequests.set(payload.id, [payload, end]);\n      var newPayload = createPayload(payload);\n      delete newPayload.origin;\n      this._socket.send(JSON.stringify(newPayload));\n      this._log(\"Sent: \".concat(newPayload.method, \" #\").concat(newPayload.id));\n    }\n  }, {\n    key: \"_handleSocketClose\",\n    value: function _handleSocketClose(_ref2) {\n      var reason = _ref2.reason,\n        code = _ref2.code;\n      this._log(\"Socket closed, code \".concat(code, \" (\").concat(reason || 'no reason', \")\"));\n      // If the socket has been open for longer than 5 seconds, reset the backoff\n      if (this._connectTime && Date.now() - this._connectTime > 5000) {\n        this._backoff.reset();\n      }\n      this._socket.removeEventListener('close', this._handleSocketClose);\n      this._socket.removeEventListener('message', this._handleSocketMessage);\n      this._socket.removeEventListener('open', this._handleSocketOpen);\n      this._socket = null;\n      this._backoff.backoff();\n    }\n  }, {\n    key: \"_handleSocketMessage\",\n    value: function _handleSocketMessage(message) {\n      var payload;\n      try {\n        payload = JSON.parse(message.data);\n      } catch (e) {\n        this._log('Received a message that is not valid JSON:', payload);\n        return;\n      }\n\n      // check if server-sent notification\n      if (payload.id === undefined) {\n        return this.engine.emit('data', null, payload);\n      }\n\n      // ignore if missing\n      if (!this._pendingRequests.has(payload.id)) {\n        return;\n      }\n\n      // retrieve payload + arguments\n      var _this$_pendingRequest = this._pendingRequests.get(payload.id),\n        _this$_pendingRequest2 = _slicedToArray(_this$_pendingRequest, 2),\n        originalReq = _this$_pendingRequest2[0],\n        end = _this$_pendingRequest2[1];\n      this._pendingRequests.delete(payload.id);\n      this._log(\"Received: \".concat(originalReq.method, \" #\").concat(payload.id));\n\n      // forward response\n      if (payload.error) {\n        return end(new Error(payload.error.message));\n      }\n      end(null, payload.result);\n    }\n  }, {\n    key: \"_handleSocketOpen\",\n    value: function _handleSocketOpen() {\n      var _this2 = this;\n      this._log('Socket open.');\n      this._connectTime = Date.now();\n\n      // Any pending requests need to be resent because our session was lost\n      // and will not get responses for them in our new session.\n      this._pendingRequests.forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          payload = _ref4[0],\n          end = _ref4[1];\n        _this2._unhandledRequests.push([payload, null, end]);\n      });\n      this._pendingRequests.clear();\n      var unhandledRequests = this._unhandledRequests.splice(0, this._unhandledRequests.length);\n      unhandledRequests.forEach(function (request) {\n        _this2.handleRequest.apply(_this2, request);\n      });\n    }\n  }, {\n    key: \"_openSocket\",\n    value: function _openSocket() {\n      this._log('Opening socket...');\n      this._socket = new WebSocket(this._url, [], this._origin ? {\n        headers: {\n          origin: this._origin\n        }\n      } : {});\n      this._socket.addEventListener('close', this._handleSocketClose);\n      this._socket.addEventListener('message', this._handleSocketMessage);\n      this._socket.addEventListener('open', this._handleSocketOpen);\n    }\n  }]);\n  return WebsocketSubprovider;\n}(Subprovider); // multiple inheritance\nObject.assign(WebsocketSubprovider.prototype, EventEmitter.prototype);\nmodule.exports = WebsocketSubprovider;","map":null,"metadata":{},"sourceType":"script"}