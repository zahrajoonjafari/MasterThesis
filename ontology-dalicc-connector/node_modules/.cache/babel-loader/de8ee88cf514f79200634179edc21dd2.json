{"ast":null,"code":"var EventEmitter = require('events').EventEmitter;\nvar inherits = require('util').inherits;\nvar ethUtil = require('ethereumjs-util');\nvar EthBlockTracker = require('eth-block-tracker');\nvar map = require('async/map');\nvar eachSeries = require('async/eachSeries');\nvar Stoplight = require('./util/stoplight.js');\nvar cacheUtils = require('./util/rpc-cache-utils.js');\nvar createPayload = require('./util/create-payload.js');\nvar noop = function noop() {};\nmodule.exports = Web3ProviderEngine;\ninherits(Web3ProviderEngine, EventEmitter);\nfunction Web3ProviderEngine(opts) {\n  var self = this;\n  EventEmitter.call(self);\n  self.setMaxListeners(30);\n  // parse options\n  opts = opts || {};\n\n  // block polling\n  var directProvider = {\n    sendAsync: self._handleAsync.bind(self)\n  };\n  var blockTrackerProvider = opts.blockTrackerProvider || directProvider;\n  self._blockTracker = opts.blockTracker || new EthBlockTracker({\n    provider: blockTrackerProvider,\n    pollingInterval: opts.pollingInterval || 4000,\n    setSkipCacheFlag: true\n  });\n\n  // set initialization blocker\n  self._ready = new Stoplight();\n\n  // local state\n  self.currentBlock = null;\n  self._providers = [];\n}\n\n// public\n\nWeb3ProviderEngine.prototype.start = function () {\n  var _this = this;\n  var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;\n  var self = this;\n\n  // trigger start\n  self._ready.go();\n\n  // on new block, request block body and emit as events\n  self._blockTracker.on('latest', function (blockNumber) {\n    // get block body\n    self._getBlockByNumberWithRetry(blockNumber, function (err, block) {\n      if (err) {\n        _this.emit('error', err);\n        return;\n      }\n      if (!block) {\n        console.log(block);\n        _this.emit('error', new Error(\"Could not find block\"));\n        return;\n      }\n      var bufferBlock = toBufferBlock(block);\n      // set current + emit \"block\" event\n      self._setCurrentBlock(bufferBlock);\n      // emit other events\n      self.emit('rawBlock', block);\n      self.emit('latest', block);\n    });\n  });\n\n  // forward other events\n  self._blockTracker.on('sync', self.emit.bind(self, 'sync'));\n  self._blockTracker.on('error', self.emit.bind(self, 'error'));\n\n  // update state\n  self._running = true;\n  // signal that we started\n  self.emit('start');\n};\nWeb3ProviderEngine.prototype.stop = function () {\n  var self = this;\n  // stop block polling by removing event listeners\n  self._blockTracker.removeAllListeners();\n  // update state\n  self._running = false;\n  // signal that we stopped\n  self.emit('stop');\n};\nWeb3ProviderEngine.prototype.isRunning = function () {\n  var self = this;\n  return self._running;\n};\nWeb3ProviderEngine.prototype.addProvider = function (source, index) {\n  var self = this;\n  if (typeof index === 'number') {\n    self._providers.splice(index, 0, source);\n  } else {\n    self._providers.push(source);\n  }\n  source.setEngine(this);\n};\nWeb3ProviderEngine.prototype.removeProvider = function (source) {\n  var self = this;\n  var index = self._providers.indexOf(source);\n  if (index < 0) throw new Error('Provider not found.');\n  self._providers.splice(index, 1);\n};\nWeb3ProviderEngine.prototype.send = function (payload) {\n  throw new Error('Web3ProviderEngine does not support synchronous requests.');\n};\nWeb3ProviderEngine.prototype.sendAsync = function (payload, cb) {\n  var self = this;\n  self._ready.await(function () {\n    if (Array.isArray(payload)) {\n      // handle batch\n      map(payload, self._handleAsync.bind(self), cb);\n    } else {\n      // handle single\n      self._handleAsync(payload, cb);\n    }\n  });\n};\n\n// private\n\nWeb3ProviderEngine.prototype._getBlockByNumberWithRetry = function (blockNumber, cb) {\n  var self = this;\n  var retriesRemaining = 5;\n  attemptRequest();\n  return;\n  function attemptRequest() {\n    self._getBlockByNumber(blockNumber, afterRequest);\n  }\n  function afterRequest(err, block) {\n    // anomalous error occurred\n    if (err) return cb(err);\n    // block not ready yet\n    if (!block) {\n      if (retriesRemaining > 0) {\n        // wait 1s then try again\n        retriesRemaining--;\n        setTimeout(function () {\n          attemptRequest();\n        }, 1000);\n        return;\n      } else {\n        // give up, return a null block\n        cb(null, null);\n        return;\n      }\n    }\n    // otherwise return result\n    cb(null, block);\n    return;\n  }\n};\nWeb3ProviderEngine.prototype._getBlockByNumber = function (blockNumber, cb) {\n  var req = createPayload({\n    method: 'eth_getBlockByNumber',\n    params: [blockNumber, false],\n    skipCache: true\n  });\n  this._handleAsync(req, function (err, res) {\n    if (err) return cb(err);\n    return cb(null, res.result);\n  });\n};\nWeb3ProviderEngine.prototype._handleAsync = function (payload, finished) {\n  var self = this;\n  var currentProvider = -1;\n  var result = null;\n  var error = null;\n  var stack = [];\n  next();\n  function next(after) {\n    currentProvider += 1;\n    stack.unshift(after);\n\n    // Bubbled down as far as we could go, and the request wasn't\n    // handled. Return an error.\n    if (currentProvider >= self._providers.length) {\n      end(new Error('Request for method \"' + payload.method + '\" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'));\n    } else {\n      try {\n        var provider = self._providers[currentProvider];\n        provider.handleRequest(payload, next, end);\n      } catch (e) {\n        end(e);\n      }\n    }\n  }\n  function end(_error, _result) {\n    error = _error;\n    result = _result;\n    eachSeries(stack, function (fn, callback) {\n      if (fn) {\n        fn(error, result, callback);\n      } else {\n        callback();\n      }\n    }, function () {\n      var resultObj = {\n        id: payload.id,\n        jsonrpc: payload.jsonrpc,\n        result: result\n      };\n      if (error != null) {\n        resultObj.error = {\n          message: error.stack || error.message || error,\n          code: -32000\n        };\n        // respond with both error formats\n        finished(error, resultObj);\n      } else {\n        finished(null, resultObj);\n      }\n    });\n  }\n};\n\n//\n// from remote-data\n//\n\nWeb3ProviderEngine.prototype._setCurrentBlock = function (block) {\n  var self = this;\n  self.currentBlock = block;\n  self.emit('block', block);\n};\n\n// util\n\nfunction toBufferBlock(jsonBlock) {\n  return {\n    number: ethUtil.toBuffer(jsonBlock.number),\n    hash: ethUtil.toBuffer(jsonBlock.hash),\n    parentHash: ethUtil.toBuffer(jsonBlock.parentHash),\n    nonce: ethUtil.toBuffer(jsonBlock.nonce),\n    mixHash: ethUtil.toBuffer(jsonBlock.mixHash),\n    sha3Uncles: ethUtil.toBuffer(jsonBlock.sha3Uncles),\n    logsBloom: ethUtil.toBuffer(jsonBlock.logsBloom),\n    transactionsRoot: ethUtil.toBuffer(jsonBlock.transactionsRoot),\n    stateRoot: ethUtil.toBuffer(jsonBlock.stateRoot),\n    receiptsRoot: ethUtil.toBuffer(jsonBlock.receiptRoot || jsonBlock.receiptsRoot),\n    miner: ethUtil.toBuffer(jsonBlock.miner),\n    difficulty: ethUtil.toBuffer(jsonBlock.difficulty),\n    totalDifficulty: ethUtil.toBuffer(jsonBlock.totalDifficulty),\n    size: ethUtil.toBuffer(jsonBlock.size),\n    extraData: ethUtil.toBuffer(jsonBlock.extraData),\n    gasLimit: ethUtil.toBuffer(jsonBlock.gasLimit),\n    gasUsed: ethUtil.toBuffer(jsonBlock.gasUsed),\n    timestamp: ethUtil.toBuffer(jsonBlock.timestamp),\n    transactions: jsonBlock.transactions\n  };\n}","map":null,"metadata":{},"sourceType":"script"}