{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uncompressedPublicKeyToAddress = exports.createAccountGeneratorFromSeedAndPath = void 0;\nvar keccak_1 = require(\"ethereum-cryptography/keccak\");\nvar crypto_1 = require(\"crypto\");\nvar secp256k1_1 = __importDefault(require(\"secp256k1\"));\nvar HARDENED_OFFSET = 0x80000000;\nvar MASTER_SECRET = Buffer.from(\"Bitcoin seed\", \"utf8\");\nfunction createAccountGeneratorFromSeedAndPath(seedBuffer, hdPath) {\n  var parent = createAccountFromSeed(seedBuffer);\n  var path = deriveFromPath(hdPath, parent);\n  return function (index) {\n    return deriveFromIndex(index, path);\n  };\n}\nexports.createAccountGeneratorFromSeedAndPath = createAccountGeneratorFromSeedAndPath;\nvar uncompressedPublicKeyToAddress = function uncompressedPublicKeyToAddress(uncompressedPublicKey) {\n  var address = Buffer.from(secp256k1_1.default.publicKeyConvert(uncompressedPublicKey, false));\n  // first byte is discarded\n  var hash = (0, keccak_1.keccak256)(address.slice(1));\n  return hash.slice(-20); // address is the last 20\n};\n\nexports.uncompressedPublicKeyToAddress = uncompressedPublicKeyToAddress;\nfunction createAccountFromSeed(seedBuffer) {\n  var I = (0, crypto_1.createHmac)(\"sha512\", MASTER_SECRET).update(seedBuffer).digest();\n  var privateKey = I.slice(0, 32);\n  var chainCode = I.slice(32);\n  var publicKey = makePublicKey(privateKey);\n  return {\n    privateKey: privateKey,\n    chainCode: chainCode,\n    publicKey: publicKey\n  };\n}\nfunction deriveFromPath(fullPath, child) {\n  fullPath.forEach(function (c, i) {\n    if (i === 0) {\n      if (!/^[mM]{1}/.test(c)) {\n        throw new Error('Path must start with \"m\" or \"M\"');\n      }\n      return;\n    }\n    var hardened = c.length > 1 && c[c.length - 1] === \"'\";\n    var childIndex = parseInt(c, 10);\n    if (childIndex >= HARDENED_OFFSET) throw new Error(\"Invalid index\");\n    if (hardened) childIndex += HARDENED_OFFSET;\n    child = deriveChild(childIndex, hardened, child.privateKey, child.publicKey, child.chainCode);\n  });\n  return child;\n}\nfunction deriveFromIndex(index, child) {\n  if (index >= HARDENED_OFFSET) throw new Error(\"Invalid index\");\n  return deriveChild(index, false, child.privateKey, child.publicKey, child.chainCode);\n}\nfunction makePublicKey(privateKey) {\n  return secp256k1_1.default.publicKeyCreate(privateKey);\n}\n/**\n * A buffer of size 4 that can be reused as long as all changes are consumed\n * within the same event loop.\n */\nvar SHARED_BUFFER_4 = Buffer.allocUnsafe(4);\nfunction deriveChild(index, isHardened, privateKey, publicKey, chainCode) {\n  var indexBuffer = SHARED_BUFFER_4;\n  indexBuffer.writeUInt32BE(index, 0);\n  var data;\n  var privateKeyLength = privateKey.length;\n  if (isHardened) {\n    // Hardened child\n    // privateKeyLength + 1 (BUFFER_ZERO.length) + 4 (indexBuffer.length)\n    var dataLength = privateKeyLength + 1 + 4;\n    data = Buffer.concat([Buffer.allocUnsafe(1).fill(0), privateKey, indexBuffer], dataLength);\n  } else {\n    // Normal child\n    data = Buffer.concat([publicKey, indexBuffer], publicKey.length + 4);\n  }\n  var I = (0, crypto_1.createHmac)(\"sha512\", chainCode).update(data).digest();\n  var IL = I.slice(0, 32);\n  try {\n    var privK = Buffer.allocUnsafe(privateKeyLength);\n    privateKey.copy(privK, 0, 0, privateKeyLength);\n    var newPrivK = secp256k1_1.default.privateKeyTweakAdd(privK, IL);\n    return {\n      privateKey: Buffer.from(newPrivK),\n      publicKey: makePublicKey(newPrivK),\n      chainCode: I.slice(32)\n    };\n  } catch (_a) {\n    return deriveChild(index + 1, isHardened, privateKey, publicKey, chainCode);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}