{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/sima/Desktop/finalMaster/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOptions = void 0;\n// check that the first argument is a mnemonic phrase\nvar isMnemonicLike = function isMnemonicLike(credentials) {\n  return typeof credentials === \"string\" && credentials.includes(\" \");\n};\n// check that the first argument is a list of private keys\nvar isPrivateKeysLike = function isPrivateKeysLike(credentials) {\n  return credentials instanceof Array;\n};\n// check that the first argument is a single private key (default case for invalid mnemonics)\nvar isPrivateKeyLike = function isPrivateKeyLike(credentials) {\n  return typeof credentials === \"string\" && credentials.length === 64 &&\n  // this is added since parseInt(mnemonic) should equal NaN (unless it starts\n  // with a-f) and private keys should parse into a valid number - this will\n  // also parse with the largest hex value, namely \"f\" * 64\n  isFinite(parseInt(credentials, 16)) && !credentials.includes(\" \");\n};\n// turn polymorphic first argument into { mnemonic } or { privateKeys }\nvar getSigningAuthorityOptions = function getSigningAuthorityOptions(credentials) {\n  if (isPrivateKeyLike(credentials)) {\n    return {\n      privateKeys: [credentials]\n    };\n  } else if (isPrivateKeysLike(credentials)) {\n    return {\n      privateKeys: credentials\n    };\n  } else if (isMnemonicLike(credentials)) {\n    return {\n      mnemonic: {\n        phrase: credentials\n      }\n    };\n  } else {\n    throw new Error(\"First argument to new HDWalletProvider() must be a mnemonic phrase, a \" + \"single private key, or a list of private keys. \" + \"Received: \".concat(JSON.stringify(credentials)));\n  }\n};\nvar fromInputOptions = function fromInputOptions(options) {\n  if (\"mnemonic\" in options && typeof options.mnemonic === \"string\") {\n    return Object.assign(Object.assign({}, options), {\n      mnemonic: {\n        phrase: options.mnemonic\n      }\n    });\n  } else {\n    return options;\n  }\n};\n// convert legacy style positional arguments to new, single-arg options format\nvar fromArguments = function fromArguments(args) {\n  // otherwise, if arguments match the old-style, extract properties and handle polymorphism\n  var _args = _slicedToArray(args, 7),\n    mnemonicPhraseOrPrivateKeys = _args[0],\n    providerOrUrl = _args[1],\n    addressIndex = _args[2],\n    numberOfAddresses = _args[3],\n    shareNonce = _args[4],\n    derivationPath = _args[5],\n    chainId = _args[6];\n  var signingAuthority = getSigningAuthorityOptions(mnemonicPhraseOrPrivateKeys);\n  return Object.assign(Object.assign({}, signingAuthority), {\n    providerOrUrl: providerOrUrl,\n    addressIndex: addressIndex,\n    numberOfAddresses: numberOfAddresses,\n    shareNonce: shareNonce,\n    derivationPath: derivationPath,\n    chainId: chainId\n  });\n};\n// type predicate guard to determine at runtime if arguments conform to\n// new-style constructor args.\nvar matchesNewInputOptions = function matchesNewInputOptions(args) {\n  var _args2 = _slicedToArray(args, 1),\n    options = _args2[0]; // new-style means exactly one argument and an object\n  if (args.length !== 1 || typeof options !== \"object\") return false;\n  // beyond that, determine based on property inclusion check for required keys\n  return (\"providerOrUrl\" in options || \"provider\" in options || \"url\" in options) && (\"privateKeys\" in options || \"mnemonic\" in options);\n};\n// type predicate guard to determine at runtime if arguments conform to\n// old-style constructor args.\nvar matchesLegacyArguments = function matchesLegacyArguments(args) {\n  return (\n    // first check for alternate (new-style) case for basic determination\n    !matchesNewInputOptions(args) &&\n    // then additionally make sure we have the two required options we need\n    args.filter(function (arg) {\n      return arg !== undefined;\n    }).length >= 2\n  );\n};\n// normalize arguments passed to constructor to match single, new-style options\n// argument\nvar getOptions = function getOptions() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (matchesNewInputOptions(args)) {\n    // if arguments already match new-style, no real transformation needed\n    var options = args[0];\n    return fromInputOptions(options);\n  } else if (matchesLegacyArguments(args)) {\n    return fromArguments(args);\n  } else {\n    var message = \"Unknown arguments format passed to new HDWalletProvider. \" + \"Please ensure you passed provider information along with either a \" + \"mnemonic or private keys.\";\n    throw new Error(message);\n  }\n};\nexports.getOptions = getOptions;","map":null,"metadata":{},"sourceType":"script"}