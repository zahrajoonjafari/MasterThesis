{"ast":null,"code":"/*\n * Uses ethereumjs-tx to sign a transaction.\n *\n * The two callbacks a user needs to implement are:\n * - getAccounts() -- array of addresses supported\n * - getPrivateKey(address) -- return private key for a given address\n *\n * Optionally approveTransaction(), approveMessage() can be supplied too.\n */\n\nvar inherits = require('util').inherits;\nvar HookedWalletProvider = require('./hooked-wallet.js');\nvar EthTx = require('ethereumjs-tx');\nvar ethUtil = require('ethereumjs-util');\nvar sigUtil = require('eth-sig-util');\nmodule.exports = HookedWalletEthTxSubprovider;\ninherits(HookedWalletEthTxSubprovider, HookedWalletProvider);\nfunction HookedWalletEthTxSubprovider(opts) {\n  var self = this;\n  HookedWalletEthTxSubprovider.super_.call(self, opts);\n  self.signTransaction = function (txData, cb) {\n    // defaults\n    if (txData.gas !== undefined) txData.gasLimit = txData.gas;\n    txData.value = txData.value || '0x00';\n    txData.data = ethUtil.addHexPrefix(txData.data);\n    opts.getPrivateKey(txData.from, function (err, privateKey) {\n      if (err) return cb(err);\n      var tx = new EthTx(txData);\n      tx.sign(privateKey);\n      cb(null, '0x' + tx.serialize().toString('hex'));\n    });\n  };\n  self.signMessage = function (msgParams, cb) {\n    opts.getPrivateKey(msgParams.from, function (err, privateKey) {\n      if (err) return cb(err);\n      var dataBuff = ethUtil.toBuffer(msgParams.data);\n      var msgHash = ethUtil.hashPersonalMessage(dataBuff);\n      var sig = ethUtil.ecsign(msgHash, privateKey);\n      var serialized = ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));\n      cb(null, serialized);\n    });\n  };\n  self.signPersonalMessage = function (msgParams, cb) {\n    opts.getPrivateKey(msgParams.from, function (err, privateKey) {\n      if (err) return cb(err);\n      var serialized = sigUtil.personalSign(privateKey, msgParams);\n      cb(null, serialized);\n    });\n  };\n  self.signTypedMessage = function (msgParams, cb) {\n    opts.getPrivateKey(msgParams.from, function (err, privateKey) {\n      if (err) return cb(err);\n      var serialized = sigUtil.signTypedData(privateKey, msgParams);\n      cb(null, serialized);\n    });\n  };\n}\nfunction concatSig(v, r, s) {\n  r = ethUtil.fromSigned(r);\n  s = ethUtil.fromSigned(s);\n  v = ethUtil.bufferToInt(v);\n  r = ethUtil.toUnsigned(r).toString('hex').padStart(64, 0);\n  s = ethUtil.toUnsigned(s).toString('hex').padStart(64, 0);\n  v = ethUtil.stripHexPrefix(ethUtil.intToHex(v));\n  return ethUtil.addHexPrefix(r.concat(s, v).toString(\"hex\"));\n}","map":null,"metadata":{},"sourceType":"script"}