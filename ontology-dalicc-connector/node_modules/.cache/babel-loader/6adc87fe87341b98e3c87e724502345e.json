{"ast":null,"code":"var inherits = require('util').inherits;\nvar Transaction = require('ethereumjs-tx');\nvar ethUtil = require('ethereumjs-util');\nvar Subprovider = require('./subprovider.js');\nvar blockTagForPayload = require('../util/rpc-cache-utils').blockTagForPayload;\nmodule.exports = NonceTrackerSubprovider;\n\n// handles the following RPC methods:\n//   eth_getTransactionCount (pending only)\n//\n// observes the following RPC methods:\n//   eth_sendRawTransaction\n//   evm_revert (to clear the nonce cache)\n\ninherits(NonceTrackerSubprovider, Subprovider);\nfunction NonceTrackerSubprovider(opts) {\n  var self = this;\n  self.nonceCache = {};\n}\nNonceTrackerSubprovider.prototype.handleRequest = function (payload, next, end) {\n  var self = this;\n  switch (payload.method) {\n    case 'eth_getTransactionCount':\n      var blockTag = blockTagForPayload(payload);\n      var address = payload.params[0].toLowerCase();\n      var cachedResult = self.nonceCache[address];\n      // only handle requests against the 'pending' blockTag\n      if (blockTag === 'pending') {\n        // has a result\n        if (cachedResult) {\n          end(null, cachedResult);\n          // fallthrough then populate cache\n        } else {\n          next(function (err, result, cb) {\n            if (err) return cb();\n            if (self.nonceCache[address] === undefined) {\n              self.nonceCache[address] = result;\n            }\n            cb();\n          });\n        }\n      } else {\n        next();\n      }\n      return;\n    case 'eth_sendRawTransaction':\n      // allow the request to continue normally\n      next(function (err, result, cb) {\n        // only update local nonce if tx was submitted correctly\n        if (err) return cb();\n        // parse raw tx\n        var rawTx = payload.params[0];\n        var stripped = ethUtil.stripHexPrefix(rawTx);\n        var rawData = Buffer.from(ethUtil.stripHexPrefix(rawTx), 'hex');\n        var tx = new Transaction(Buffer.from(ethUtil.stripHexPrefix(rawTx), 'hex'));\n        // extract address\n        var address = '0x' + tx.getSenderAddress().toString('hex').toLowerCase();\n        // extract nonce and increment\n        var nonce = ethUtil.bufferToInt(tx.nonce);\n        nonce++;\n        // hexify and normalize\n        var hexNonce = nonce.toString(16);\n        if (hexNonce.length % 2) hexNonce = '0' + hexNonce;\n        hexNonce = '0x' + hexNonce;\n        // dont update our record on the nonce until the submit was successful\n        // update cache\n        self.nonceCache[address] = hexNonce;\n        cb();\n      });\n      return;\n\n    // Clear cache on a testrpc revert\n    case 'evm_revert':\n      self.nonceCache = {};\n      next();\n      return;\n    default:\n      next();\n      return;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}