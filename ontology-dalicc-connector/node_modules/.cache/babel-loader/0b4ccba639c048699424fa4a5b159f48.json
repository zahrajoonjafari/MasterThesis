{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nexport function assertNumber(n) {\n  if (!Number.isSafeInteger(n)) throw new Error(\"Wrong integer: \".concat(n));\n}\nfunction chain() {\n  var wrap = function wrap(a, b) {\n    return function (c) {\n      return a(b(c));\n    };\n  };\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  var encode = Array.from(args).reverse().reduce(function (acc, i) {\n    return acc ? wrap(acc, i.encode) : i.encode;\n  }, undefined);\n  var decode = args.reduce(function (acc, i) {\n    return acc ? wrap(acc, i.decode) : i.decode;\n  }, undefined);\n  return {\n    encode: encode,\n    decode: decode\n  };\n}\nfunction alphabet(alphabet) {\n  return {\n    encode: function encode(digits) {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('alphabet.encode input should be an array of numbers');\n      return digits.map(function (i) {\n        assertNumber(i);\n        if (i < 0 || i >= alphabet.length) throw new Error(\"Digit index outside alphabet: \".concat(i, \" (alphabet: \").concat(alphabet.length, \")\"));\n        return alphabet[i];\n      });\n    },\n    decode: function decode(input) {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('alphabet.decode input should be array of strings');\n      return input.map(function (letter) {\n        if (typeof letter !== 'string') throw new Error(\"alphabet.decode: not string element=\".concat(letter));\n        var index = alphabet.indexOf(letter);\n        if (index === -1) throw new Error(\"Unknown letter: \\\"\".concat(letter, \"\\\". Allowed: \").concat(alphabet));\n        return index;\n      });\n    }\n  };\n}\nfunction join() {\n  var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  if (typeof separator !== 'string') throw new Error('join separator should be string');\n  return {\n    encode: function encode(from) {\n      if (!Array.isArray(from) || from.length && typeof from[0] !== 'string') throw new Error('join.encode input should be array of strings');\n      var _iterator = _createForOfIteratorHelper(from),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var i = _step.value;\n          if (typeof i !== 'string') throw new Error(\"join.encode: non-string input=\".concat(i));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return from.join(separator);\n    },\n    decode: function decode(to) {\n      if (typeof to !== 'string') throw new Error('join.decode input should be string');\n      return to.split(separator);\n    }\n  };\n}\nfunction padding(bits) {\n  var chr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '=';\n  assertNumber(bits);\n  if (typeof chr !== 'string') throw new Error('padding chr should be string');\n  return {\n    encode: function encode(data) {\n      if (!Array.isArray(data) || data.length && typeof data[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n      var _iterator2 = _createForOfIteratorHelper(data),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var i = _step2.value;\n          if (typeof i !== 'string') throw new Error(\"padding.encode: non-string input=\".concat(i));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      while (data.length * bits % 8) data.push(chr);\n      return data;\n    },\n    decode: function decode(input) {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n      var _iterator3 = _createForOfIteratorHelper(input),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var i = _step3.value;\n          if (typeof i !== 'string') throw new Error(\"padding.decode: non-string input=\".concat(i));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var end = input.length;\n      if (end * bits % 8) throw new Error('Invalid padding: string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        if (!((end - 1) * bits % 8)) throw new Error('Invalid padding: string has too much padding');\n      }\n      return input.slice(0, end);\n    }\n  };\n}\nfunction normalize(fn) {\n  if (typeof fn !== 'function') throw new Error('normalize fn should be function');\n  return {\n    encode: function encode(from) {\n      return from;\n    },\n    decode: function decode(to) {\n      return fn(to);\n    }\n  };\n}\nfunction convertRadix(data, from, to) {\n  if (from < 2) throw new Error(\"convertRadix: wrong from=\".concat(from, \", base cannot be less than 2\"));\n  if (to < 2) throw new Error(\"convertRadix: wrong to=\".concat(to, \", base cannot be less than 2\"));\n  if (!Array.isArray(data)) throw new Error('convertRadix: data should be array');\n  if (!data.length) return [];\n  var pos = 0;\n  var res = [];\n  var digits = Array.from(data);\n  digits.forEach(function (d) {\n    assertNumber(d);\n    if (d < 0 || d >= from) throw new Error(\"Wrong integer: \".concat(d));\n  });\n  while (true) {\n    var carry = 0;\n    var done = true;\n    for (var i = pos; i < digits.length; i++) {\n      var digit = digits[i];\n      var digitBase = from * carry + digit;\n      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      carry = digitBase % to;\n      digits[i] = Math.floor(digitBase / to);\n      if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');\n      if (!done) continue;else if (!digits[i]) pos = i;else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (var _i = 0; _i < data.length - 1 && data[_i] === 0; _i++) res.push(0);\n  return res.reverse();\n}\nvar gcd = function gcd(a, b) {\n  return !b ? a : gcd(b, a % b);\n};\nvar radix2carry = function radix2carry(from, to) {\n  return from + (to - gcd(from, to));\n};\nfunction convertRadix2(data, from, to, padding) {\n  if (!Array.isArray(data)) throw new Error('convertRadix2: data should be array');\n  if (from <= 0 || from > 32) throw new Error(\"convertRadix2: wrong from=\".concat(from));\n  if (to <= 0 || to > 32) throw new Error(\"convertRadix2: wrong to=\".concat(to));\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\"convertRadix2: carry overflow from=\".concat(from, \" to=\").concat(to, \" carryBits=\").concat(radix2carry(from, to)));\n  }\n  var carry = 0;\n  var pos = 0;\n  var mask = Math.pow(2, to) - 1;\n  var res = [];\n  var _iterator4 = _createForOfIteratorHelper(data),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var n = _step4.value;\n      assertNumber(n);\n      if (n >= Math.pow(2, from)) throw new Error(\"convertRadix2: invalid data word=\".concat(n, \" from=\").concat(from));\n      carry = carry << from | n;\n      if (pos + from > 32) throw new Error(\"convertRadix2: carry overflow pos=\".concat(pos, \" from=\").concat(from));\n      pos += from;\n      for (; pos >= to; pos -= to) res.push((carry >> pos - to & mask) >>> 0);\n      carry &= Math.pow(2, pos) - 1;\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  carry = carry << to - pos & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry) throw new Error(\"Non-zero padding: \".concat(carry));\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\nfunction radix(num) {\n  assertNumber(num);\n  return {\n    encode: function encode(bytes) {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), Math.pow(2, 8), num);\n    },\n    decode: function decode(digits) {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix.decode input should be array of strings');\n      return Uint8Array.from(convertRadix(digits, num, Math.pow(2, 8)));\n    }\n  };\n}\nfunction radix2(bits) {\n  var revPadding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  assertNumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');\n  return {\n    encode: function encode(bytes) {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: function decode(digits) {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix2.decode input should be array of strings');\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    }\n  };\n}\nfunction unsafeWrapper(fn) {\n  if (typeof fn !== 'function') throw new Error('unsafeWrapper fn should be function');\n  return function () {\n    try {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\nfunction checksum(len, fn) {\n  assertNumber(len);\n  if (typeof fn !== 'function') throw new Error('checksum fn should be function');\n  return {\n    encode: function encode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.encode: input should be Uint8Array');\n      var checksum = fn(data).slice(0, len);\n      var res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(checksum, data.length);\n      return res;\n    },\n    decode: function decode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.decode: input should be Uint8Array');\n      var payload = data.slice(0, -len);\n      var newChecksum = fn(payload).slice(0, len);\n      var oldChecksum = data.slice(-len);\n      for (var i = 0; i < len; i++) if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    }\n  };\n}\nexport var utils = {\n  alphabet: alphabet,\n  chain: chain,\n  checksum: checksum,\n  radix: radix,\n  radix2: radix2,\n  join: join,\n  padding: padding\n};\nexport var base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexport var base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexport var base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexport var base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize(function (s) {\n  return s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1');\n}));\nexport var base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexport var base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nvar genBase58 = function genBase58(abc) {\n  return chain(radix(58), alphabet(abc), join(''));\n};\nexport var base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexport var base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexport var base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nvar XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexport var base58xmr = {\n  encode: function encode(data) {\n    var res = '';\n    for (var i = 0; i < data.length; i += 8) {\n      var block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n    }\n    return res;\n  },\n  decode: function decode(str) {\n    var res = [];\n    for (var i = 0; i < str.length; i += 11) {\n      var slice = str.slice(i, i + 11);\n      var blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      var block = base58.decode(slice);\n      for (var j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  }\n};\nexport var base58check = function base58check(sha256) {\n  return chain(checksum(4, function (data) {\n    return sha256(sha256(data));\n  }), base58);\n};\nvar BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nvar POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n  var b = pre >> 25;\n  var chk = (pre & 0x1ffffff) << 5;\n  for (var i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n  }\n  return chk;\n}\nfunction bechChecksum(prefix, words) {\n  var encodingConst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var len = prefix.length;\n  var chk = 1;\n  for (var i = 0; i < len; i++) {\n    var c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(\"Invalid prefix (\".concat(prefix, \")\"));\n    chk = bech32Polymod(chk) ^ c >> 5;\n  }\n  chk = bech32Polymod(chk);\n  for (var _i2 = 0; _i2 < len; _i2++) chk = bech32Polymod(chk) ^ prefix.charCodeAt(_i2) & 0x1f;\n  var _iterator5 = _createForOfIteratorHelper(words),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var v = _step5.value;\n      chk = bech32Polymod(chk) ^ v;\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  for (var _i3 = 0; _i3 < 6; _i3++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % Math.pow(2, 30)], 30, 5, false));\n}\nfunction genBech32(encoding) {\n  var ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  var _words = radix2(5);\n  var fromWords = _words.decode;\n  var toWords = _words.encode;\n  var fromWordsUnsafe = unsafeWrapper(fromWords);\n  function encode(prefix, words) {\n    var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 90;\n    if (typeof prefix !== 'string') throw new Error(\"bech32.encode prefix should be string, not \".concat(typeof prefix));\n    if (!Array.isArray(words) || words.length && typeof words[0] !== 'number') throw new Error(\"bech32.encode words should be array of numbers, not \".concat(typeof words));\n    var actualLength = prefix.length + 7 + words.length;\n    if (limit !== false && actualLength > limit) throw new TypeError(\"Length \".concat(actualLength, \" exceeds limit \").concat(limit));\n    prefix = prefix.toLowerCase();\n    return \"\".concat(prefix, \"1\").concat(BECH_ALPHABET.encode(words)).concat(bechChecksum(prefix, words, ENCODING_CONST));\n  }\n  function decode(str) {\n    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 90;\n    if (typeof str !== 'string') throw new Error(\"bech32.decode input should be string, not \".concat(typeof str));\n    if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(\"Wrong string length: \".concat(str.length, \" (\").concat(str, \"). Expected (8..\").concat(limit, \")\"));\n    var lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase()) throw new Error(\"String must be lowercase or uppercase\");\n    str = lowered;\n    var sepIndex = str.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1) throw new Error(\"Letter \\\"1\\\" must be present between prefix and data only\");\n    var prefix = str.slice(0, sepIndex);\n    var _words = str.slice(sepIndex + 1);\n    if (_words.length < 6) throw new Error('Data must be at least 6 characters long');\n    var words = BECH_ALPHABET.decode(_words).slice(0, -6);\n    var sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!_words.endsWith(sum)) throw new Error(\"Invalid checksum in \".concat(str, \": expected \\\"\").concat(sum, \"\\\"\"));\n    return {\n      prefix: prefix,\n      words: words\n    };\n  }\n  var decodeUnsafe = unsafeWrapper(decode);\n  function decodeToBytes(str) {\n    var _decode = decode(str, false),\n      prefix = _decode.prefix,\n      words = _decode.words;\n    return {\n      prefix: prefix,\n      words: words,\n      bytes: fromWords(words)\n    };\n  }\n  return {\n    encode: encode,\n    decode: decode,\n    decodeToBytes: decodeToBytes,\n    decodeUnsafe: decodeUnsafe,\n    fromWords: fromWords,\n    fromWordsUnsafe: fromWordsUnsafe,\n    toWords: toWords\n  };\n}\nexport var bech32 = genBech32('bech32');\nexport var bech32m = genBech32('bech32m');\nexport var utf8 = {\n  encode: function encode(data) {\n    return new TextDecoder().decode(data);\n  },\n  decode: function decode(str) {\n    return new TextEncoder().encode(str);\n  }\n};\nexport var hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize(function (s) {\n  if (typeof s !== 'string' || s.length % 2) throw new TypeError(\"hex.decode: expected string, got \".concat(typeof s, \" with length \").concat(s.length));\n  return s.toLowerCase();\n}));\nvar CODERS = {\n  utf8: utf8,\n  hex: hex,\n  base16: base16,\n  base32: base32,\n  base64: base64,\n  base64url: base64url,\n  base58: base58,\n  base58xmr: base58xmr\n};\nvar coderTypeError = \"Invalid encoding type. Available types: \".concat(Object.keys(CODERS).join(', '));\nexport var bytesToString = function bytesToString(type, bytes) {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!(bytes instanceof Uint8Array)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\nexport var str = bytesToString;\nexport var stringToBytes = function stringToBytes(type, str) {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\nexport var bytes = stringToBytes;","map":null,"metadata":{},"sourceType":"module"}