{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/sima/Desktop/finalMaster (copy)/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/sima/Desktop/finalMaster (copy)/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/home/sima/Desktop/finalMaster (copy)/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/sima/Desktop/finalMaster (copy)/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/sima/Desktop/finalMaster (copy)/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar events_1 = require(\"events\");\nfunction safeApply(handler, context, args) {\n  try {\n    Reflect.apply(handler, context, args);\n  } catch (err) {\n    // Throw error after timeout so as not to interrupt the stack\n    setTimeout(function () {\n      throw err;\n    });\n  }\n}\nfunction arrayClone(arr) {\n  var n = arr.length;\n  var copy = new Array(n);\n  for (var i = 0; i < n; i += 1) {\n    copy[i] = arr[i];\n  }\n  return copy;\n}\nvar SafeEventEmitter = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(SafeEventEmitter, _events_1$EventEmitte);\n  function SafeEventEmitter() {\n    _classCallCheck(this, SafeEventEmitter);\n    return _possibleConstructorReturn(this, _getPrototypeOf(SafeEventEmitter).apply(this, arguments));\n  }\n  _createClass(SafeEventEmitter, [{\n    key: \"emit\",\n    value: function emit(type) {\n      var doError = type === 'error';\n      var events = this._events;\n      if (events !== undefined) {\n        doError = doError && events.error === undefined;\n      } else if (!doError) {\n        return false;\n      }\n      // If there is no 'error' event listener then throw.\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      if (doError) {\n        var er;\n        if (args.length > 0) {\n          er = args[0];\n        }\n        if (er instanceof Error) {\n          // Note: The comments on the `throw` lines are intentional, they show\n          // up in Node's output if this results in an unhandled exception.\n          throw er; // Unhandled 'error' event\n        }\n        // At least give some kind of context to the user\n        var err = new Error(\"Unhandled error.\".concat(er ? \" (\".concat(er.message, \")\") : ''));\n        err.context = er;\n        throw err; // Unhandled 'error' event\n      }\n\n      var handler = events[type];\n      if (handler === undefined) {\n        return false;\n      }\n      if (typeof handler === 'function') {\n        safeApply(handler, this, args);\n      } else {\n        var len = handler.length;\n        var listeners = arrayClone(handler);\n        for (var i = 0; i < len; i += 1) {\n          safeApply(listeners[i], this, args);\n        }\n      }\n      return true;\n    }\n  }]);\n  return SafeEventEmitter;\n}(events_1.EventEmitter);\nexports.default = SafeEventEmitter;","map":null,"metadata":{},"sourceType":"script"}