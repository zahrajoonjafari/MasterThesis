{"ast":null,"code":"/*\n * Emulate 'eth_accounts' / 'eth_sendTransaction' using 'eth_sendRawTransaction'\n *\n * The two callbacks a user needs to implement are:\n * - getAccounts() -- array of addresses supported\n * - signTransaction(tx) -- sign a raw transaction object\n */\n\nvar waterfall = require('async/waterfall');\nvar parallel = require('async/parallel');\nvar inherits = require('util').inherits;\nvar ethUtil = require('ethereumjs-util');\nvar sigUtil = require('eth-sig-util');\nvar extend = require('xtend');\nvar Semaphore = require('semaphore');\nvar Subprovider = require('./subprovider.js');\nvar estimateGas = require('../util/estimate-gas.js');\nvar hexRegex = /^[0-9A-Fa-f]+$/g;\nmodule.exports = HookedWalletSubprovider;\n\n// handles the following RPC methods:\n//   eth_coinbase\n//   eth_accounts\n//   eth_sendTransaction\n//   eth_sign\n//   eth_signTypedData\n//   eth_signTypedData_v3\n//   eth_signTypedData_v4\n//   personal_sign\n//   eth_decryptMessage\n//   encryption_public_key\n//   personal_ecRecover\n//   parity_postTransaction\n//   parity_checkRequest\n//   parity_defaultAccount\n\n//\n// Tx Signature Flow\n//\n// handleRequest: eth_sendTransaction\n//   validateTransaction (basic validity check)\n//     validateSender (checks that sender is in accounts)\n//   processTransaction (sign tx and submit to network)\n//     approveTransaction (UI approval hook)\n//     checkApproval\n//     finalizeAndSubmitTx (tx signing)\n//       nonceLock.take (bottle neck to ensure atomic nonce)\n//         fillInTxExtras (set fallback gasPrice, nonce, etc)\n//         signTransaction (perform the signature)\n//         publishTransaction (publish signed tx to network)\n//\n\ninherits(HookedWalletSubprovider, Subprovider);\nfunction HookedWalletSubprovider(opts) {\n  var self = this;\n  // control flow\n  self.nonceLock = Semaphore(1);\n\n  // data lookup\n  if (opts.getAccounts) self.getAccounts = opts.getAccounts;\n  // high level override\n  if (opts.processTransaction) self.processTransaction = opts.processTransaction;\n  if (opts.processMessage) self.processMessage = opts.processMessage;\n  if (opts.processPersonalMessage) self.processPersonalMessage = opts.processPersonalMessage;\n  if (opts.processTypedMessage) self.processTypedMessage = opts.processTypedMessage;\n  // approval hooks\n  self.approveTransaction = opts.approveTransaction || self.autoApprove;\n  self.approveMessage = opts.approveMessage || self.autoApprove;\n  self.approvePersonalMessage = opts.approvePersonalMessage || self.autoApprove;\n  self.approveDecryptMessage = opts.approveDecryptMessage || self.autoApprove;\n  self.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self.autoApprove;\n  self.approveTypedMessage = opts.approveTypedMessage || self.autoApprove;\n  // actually perform the signature\n  if (opts.signTransaction) self.signTransaction = opts.signTransaction || mustProvideInConstructor('signTransaction');\n  if (opts.signMessage) self.signMessage = opts.signMessage || mustProvideInConstructor('signMessage');\n  if (opts.signPersonalMessage) self.signPersonalMessage = opts.signPersonalMessage || mustProvideInConstructor('signPersonalMessage');\n  if (opts.decryptMessage) self.decryptMessage = opts.decryptMessage || mustProvideInConstructor('decryptMessage');\n  if (opts.encryptionPublicKey) self.encryptionPublicKey = opts.encryptionPublicKey || mustProvideInConstructor('encryptionPublicKey');\n  if (opts.signTypedMessage) self.signTypedMessage = opts.signTypedMessage || mustProvideInConstructor('signTypedMessage');\n  if (opts.recoverPersonalSignature) self.recoverPersonalSignature = opts.recoverPersonalSignature;\n  // publish to network\n  if (opts.publishTransaction) self.publishTransaction = opts.publishTransaction;\n  // gas options\n  self.estimateGas = opts.estimateGas || self.estimateGas;\n  self.getGasPrice = opts.getGasPrice || self.getGasPrice;\n}\nHookedWalletSubprovider.prototype.handleRequest = function (payload, next, end) {\n  var self = this;\n  self._parityRequests = {};\n  self._parityRequestCount = 0;\n\n  // switch statement is not block scoped\n  // sp we cant repeat var declarations\n  var txParams, msgParams, extraParams;\n  var message, address;\n  switch (payload.method) {\n    case 'eth_coinbase':\n      // process normally\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        var result = accounts[0] || null;\n        end(null, result);\n      });\n      return;\n    case 'eth_accounts':\n      // process normally\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        end(null, accounts);\n      });\n      return;\n    case 'eth_sendTransaction':\n      txParams = payload.params[0];\n      waterfall([function (cb) {\n        return self.validateTransaction(txParams, cb);\n      }, function (cb) {\n        return self.processTransaction(txParams, cb);\n      }], end);\n      return;\n    case 'eth_signTransaction':\n      txParams = payload.params[0];\n      waterfall([function (cb) {\n        return self.validateTransaction(txParams, cb);\n      }, function (cb) {\n        return self.processSignTransaction(txParams, cb);\n      }], end);\n      return;\n    case 'eth_sign':\n      // process normally\n      address = payload.params[0];\n      message = payload.params[1];\n      // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n      // good place for metadata\n      extraParams = payload.params[2] || {};\n      msgParams = extend(extraParams, {\n        from: address,\n        data: message\n      });\n      waterfall([function (cb) {\n        return self.validateMessage(msgParams, cb);\n      }, function (cb) {\n        return self.processMessage(msgParams, cb);\n      }], end);\n      return;\n    case 'personal_sign':\n      return function () {\n        // process normally\n        var first = payload.params[0];\n        var second = payload.params[1];\n\n        // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n        if (resemblesData(second) && resemblesAddress(first)) {\n          var warning = \"The eth_personalSign method requires params ordered \";\n          warning += \"[message, address]. This was previously handled incorrectly, \";\n          warning += \"and has been corrected automatically. \";\n          warning += \"Please switch this param order for smooth behavior in the future.\";\n          console.warn(warning);\n          address = payload.params[0];\n          message = payload.params[1];\n        } else {\n          message = payload.params[0];\n          address = payload.params[1];\n        }\n\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message\n        });\n        waterfall([function (cb) {\n          return self.validatePersonalMessage(msgParams, cb);\n        }, function (cb) {\n          return self.processPersonalMessage(msgParams, cb);\n        }], end);\n      }();\n    case 'eth_decryptMessage':\n      return function () {\n        // process normally\n        var first = payload.params[0];\n        var second = payload.params[1];\n\n        // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n        if (resemblesData(second) && resemblesAddress(first)) {\n          var warning = \"The eth_decryptMessage method requires params ordered \";\n          warning += \"[message, address]. This was previously handled incorrectly, \";\n          warning += \"and has been corrected automatically. \";\n          warning += \"Please switch this param order for smooth behavior in the future.\";\n          console.warn(warning);\n          address = payload.params[0];\n          message = payload.params[1];\n        } else {\n          message = payload.params[0];\n          address = payload.params[1];\n        }\n\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message\n        });\n        waterfall([function (cb) {\n          return self.validateDecryptMessage(msgParams, cb);\n        }, function (cb) {\n          return self.processDecryptMessage(msgParams, cb);\n        }], end);\n      }();\n    case 'encryption_public_key':\n      return function () {\n        var address = payload.params[0];\n        waterfall([function (cb) {\n          return self.validateEncryptionPublicKey(address, cb);\n        }, function (cb) {\n          return self.processEncryptionPublicKey(address, cb);\n        }], end);\n      }();\n    case 'personal_ecRecover':\n      return function () {\n        message = payload.params[0];\n        var signature = payload.params[1];\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          sig: signature,\n          data: message\n        });\n        self.recoverPersonalSignature(msgParams, end);\n      }();\n    case 'eth_signTypedData':\n    case 'eth_signTypedData_v3':\n    case 'eth_signTypedData_v4':\n      return function () {\n        // process normally\n\n        var first = payload.params[0];\n        var second = payload.params[1];\n        if (resemblesAddress(first)) {\n          address = first;\n          message = second;\n        } else {\n          message = first;\n          address = second;\n        }\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message\n        });\n        waterfall([function (cb) {\n          return self.validateTypedMessage(msgParams, cb);\n        }, function (cb) {\n          return self.processTypedMessage(msgParams, cb);\n        }], end);\n      }();\n    case 'parity_postTransaction':\n      txParams = payload.params[0];\n      self.parityPostTransaction(txParams, end);\n      return;\n    case 'parity_postSign':\n      address = payload.params[0];\n      message = payload.params[1];\n      self.parityPostSign(address, message, end);\n      return;\n    case 'parity_checkRequest':\n      return function () {\n        var requestId = payload.params[0];\n        self.parityCheckRequest(requestId, end);\n      }();\n    case 'parity_defaultAccount':\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        var account = accounts[0] || null;\n        end(null, account);\n      });\n      return;\n    default:\n      next();\n      return;\n  }\n};\n\n//\n// data lookup\n//\n\nHookedWalletSubprovider.prototype.getAccounts = function (cb) {\n  cb(null, []);\n};\n\n//\n// \"process\" high level flow\n//\n\nHookedWalletSubprovider.prototype.processTransaction = function (txParams, cb) {\n  var self = this;\n  waterfall([function (cb) {\n    return self.approveTransaction(txParams, cb);\n  }, function (didApprove, cb) {\n    return self.checkApproval('transaction', didApprove, cb);\n  }, function (cb) {\n    return self.finalizeAndSubmitTx(txParams, cb);\n  }], cb);\n};\nHookedWalletSubprovider.prototype.processSignTransaction = function (txParams, cb) {\n  var self = this;\n  waterfall([function (cb) {\n    return self.approveTransaction(txParams, cb);\n  }, function (didApprove, cb) {\n    return self.checkApproval('transaction', didApprove, cb);\n  }, function (cb) {\n    return self.finalizeTx(txParams, cb);\n  }], cb);\n};\nHookedWalletSubprovider.prototype.processMessage = function (msgParams, cb) {\n  var self = this;\n  waterfall([function (cb) {\n    return self.approveMessage(msgParams, cb);\n  }, function (didApprove, cb) {\n    return self.checkApproval('message', didApprove, cb);\n  }, function (cb) {\n    return self.signMessage(msgParams, cb);\n  }], cb);\n};\nHookedWalletSubprovider.prototype.processPersonalMessage = function (msgParams, cb) {\n  var self = this;\n  waterfall([function (cb) {\n    return self.approvePersonalMessage(msgParams, cb);\n  }, function (didApprove, cb) {\n    return self.checkApproval('message', didApprove, cb);\n  }, function (cb) {\n    return self.signPersonalMessage(msgParams, cb);\n  }], cb);\n};\nHookedWalletSubprovider.prototype.processDecryptMessage = function (msgParams, cb) {\n  var self = this;\n  waterfall([function (cb) {\n    return self.approveDecryptMessage(msgParams, cb);\n  }, function (didApprove, cb) {\n    return self.checkApproval('decryptMessage', didApprove, cb);\n  }, function (cb) {\n    return self.decryptMessage(msgParams, cb);\n  }], cb);\n};\nHookedWalletSubprovider.prototype.processEncryptionPublicKey = function (msgParams, cb) {\n  var self = this;\n  waterfall([function (cb) {\n    return self.approveEncryptionPublicKey(msgParams, cb);\n  }, function (didApprove, cb) {\n    return self.checkApproval('encryptionPublicKey', didApprove, cb);\n  }, function (cb) {\n    return self.encryptionPublicKey(msgParams, cb);\n  }], cb);\n};\nHookedWalletSubprovider.prototype.processTypedMessage = function (msgParams, cb) {\n  var self = this;\n  waterfall([function (cb) {\n    return self.approveTypedMessage(msgParams, cb);\n  }, function (didApprove, cb) {\n    return self.checkApproval('message', didApprove, cb);\n  }, function (cb) {\n    return self.signTypedMessage(msgParams, cb);\n  }], cb);\n};\n\n//\n// approval\n//\n\nHookedWalletSubprovider.prototype.autoApprove = function (txParams, cb) {\n  cb(null, true);\n};\nHookedWalletSubprovider.prototype.checkApproval = function (type, didApprove, cb) {\n  cb(didApprove ? null : new Error('User denied ' + type + ' signature.'));\n};\n\n//\n// parity\n//\n\nHookedWalletSubprovider.prototype.parityPostTransaction = function (txParams, cb) {\n  var self = this;\n\n  // get next id\n  var count = self._parityRequestCount;\n  var reqId = \"0x\".concat(count.toString(16));\n  self._parityRequestCount++;\n  self.emitPayload({\n    method: 'eth_sendTransaction',\n    params: [txParams]\n  }, function (error, res) {\n    if (error) {\n      self._parityRequests[reqId] = {\n        error: error\n      };\n      return;\n    }\n    var txHash = res.result;\n    self._parityRequests[reqId] = txHash;\n  });\n  cb(null, reqId);\n};\nHookedWalletSubprovider.prototype.parityPostSign = function (address, message, cb) {\n  var self = this;\n\n  // get next id\n  var count = self._parityRequestCount;\n  var reqId = \"0x\".concat(count.toString(16));\n  self._parityRequestCount++;\n  self.emitPayload({\n    method: 'eth_sign',\n    params: [address, message]\n  }, function (error, res) {\n    if (error) {\n      self._parityRequests[reqId] = {\n        error: error\n      };\n      return;\n    }\n    var result = res.result;\n    self._parityRequests[reqId] = result;\n  });\n  cb(null, reqId);\n};\nHookedWalletSubprovider.prototype.parityCheckRequest = function (reqId, cb) {\n  var self = this;\n  var result = self._parityRequests[reqId] || null;\n  // tx not handled yet\n  if (!result) return cb(null, null);\n  // tx was rejected (or other error)\n  if (result.error) return cb(result.error);\n  // tx sent\n  cb(null, result);\n};\n\n//\n// signature and recovery\n//\n\nHookedWalletSubprovider.prototype.recoverPersonalSignature = function (msgParams, cb) {\n  var senderHex;\n  try {\n    senderHex = sigUtil.recoverPersonalSignature(msgParams);\n  } catch (err) {\n    return cb(err);\n  }\n  cb(null, senderHex);\n};\n\n//\n// validation\n//\n\nHookedWalletSubprovider.prototype.validateTransaction = function (txParams, cb) {\n  var self = this;\n  // shortcut: undefined sender is invalid\n  if (txParams.from === undefined) return cb(new Error(\"Undefined address - from address required to sign transaction.\"));\n  self.validateSender(txParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(\"Unknown address - unable to sign transaction for this address: \\\"\".concat(txParams.from, \"\\\"\")));\n    cb();\n  });\n};\nHookedWalletSubprovider.prototype.validateMessage = function (msgParams, cb) {\n  var self = this;\n  if (msgParams.from === undefined) return cb(new Error(\"Undefined address - from address required to sign message.\"));\n  self.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(\"Unknown address - unable to sign message for this address: \\\"\".concat(msgParams.from, \"\\\"\")));\n    cb();\n  });\n};\nHookedWalletSubprovider.prototype.validatePersonalMessage = function (msgParams, cb) {\n  var self = this;\n  if (msgParams.from === undefined) return cb(new Error(\"Undefined address - from address required to sign personal message.\"));\n  if (msgParams.data === undefined) return cb(new Error(\"Undefined message - message required to sign personal message.\"));\n  if (!isValidHex(msgParams.data)) return cb(new Error(\"HookedWalletSubprovider - validateMessage - message was not encoded as hex.\"));\n  self.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(\"Unknown address - unable to sign message for this address: \\\"\".concat(msgParams.from, \"\\\"\")));\n    cb();\n  });\n};\nHookedWalletSubprovider.prototype.validateDecryptMessage = function (msgParams, cb) {\n  var self = this;\n  if (msgParams.from === undefined) return cb(new Error(\"Undefined address - from address required to decrypt message.\"));\n  if (msgParams.data === undefined) return cb(new Error(\"Undefined message - message required to decrypt message.\"));\n  if (!isValidHex(msgParams.data)) return cb(new Error(\"HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex.\"));\n  self.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(\"Unknown address - unable to decrypt message for this address: \\\"\".concat(msgParams.from, \"\\\"\")));\n    cb();\n  });\n};\nHookedWalletSubprovider.prototype.validateEncryptionPublicKey = function (address, cb) {\n  var self = this;\n  self.validateSender(address, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(\"Unknown address - unable to obtain encryption public key for this address: \\\"\".concat(address, \"\\\"\")));\n    cb();\n  });\n};\nHookedWalletSubprovider.prototype.validateTypedMessage = function (msgParams, cb) {\n  if (msgParams.from === undefined) return cb(new Error(\"Undefined address - from address required to sign typed data.\"));\n  if (msgParams.data === undefined) return cb(new Error(\"Undefined data - message required to sign typed data.\"));\n  this.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(\"Unknown address - unable to sign message for this address: \\\"\".concat(msgParams.from, \"\\\"\")));\n    cb();\n  });\n};\nHookedWalletSubprovider.prototype.validateSender = function (senderAddress, cb) {\n  var self = this;\n  // shortcut: undefined sender is invalid\n  if (!senderAddress) return cb(null, false);\n  self.getAccounts(function (err, accounts) {\n    if (err) return cb(err);\n    var senderIsValid = accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1;\n    cb(null, senderIsValid);\n  });\n};\n\n//\n// tx helpers\n//\n\nHookedWalletSubprovider.prototype.finalizeAndSubmitTx = function (txParams, cb) {\n  var self = this;\n  // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n  self.nonceLock.take(function () {\n    waterfall([self.fillInTxExtras.bind(self, txParams), self.signTransaction.bind(self), self.publishTransaction.bind(self)], function (err, txHash) {\n      self.nonceLock.leave();\n      if (err) return cb(err);\n      cb(null, txHash);\n    });\n  });\n};\nHookedWalletSubprovider.prototype.finalizeTx = function (txParams, cb) {\n  var self = this;\n  // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n  self.nonceLock.take(function () {\n    waterfall([self.fillInTxExtras.bind(self, txParams), self.signTransaction.bind(self)], function (err, signedTx) {\n      self.nonceLock.leave();\n      if (err) return cb(err);\n      cb(null, {\n        raw: signedTx,\n        tx: txParams\n      });\n    });\n  });\n};\nHookedWalletSubprovider.prototype.publishTransaction = function (rawTx, cb) {\n  var self = this;\n  self.emitPayload({\n    method: 'eth_sendRawTransaction',\n    params: [rawTx]\n  }, function (err, res) {\n    if (err) return cb(err);\n    cb(null, res.result);\n  });\n};\nHookedWalletSubprovider.prototype.estimateGas = function (txParams, cb) {\n  var self = this;\n  estimateGas(self.engine, txParams, cb);\n};\nHookedWalletSubprovider.prototype.getGasPrice = function (cb) {\n  var self = this;\n  self.emitPayload({\n    method: 'eth_gasPrice',\n    params: []\n  }, function (err, res) {\n    if (err) return cb(err);\n    cb(null, res.result);\n  });\n};\nHookedWalletSubprovider.prototype.fillInTxExtras = function (txParams, cb) {\n  var self = this;\n  var address = txParams.from;\n  // console.log('fillInTxExtras - address:', address)\n\n  var tasks = {};\n  if (txParams.gasPrice === undefined) {\n    // console.log(\"need to get gasprice\")\n    tasks.gasPrice = self.getGasPrice.bind(self);\n  }\n  if (txParams.nonce === undefined) {\n    // console.log(\"need to get nonce\")\n    tasks.nonce = self.emitPayload.bind(self, {\n      method: 'eth_getTransactionCount',\n      params: [address, 'pending']\n    });\n  }\n  if (txParams.gas === undefined) {\n    // console.log(\"need to get gas\")\n    tasks.gas = self.estimateGas.bind(self, cloneTxParams(txParams));\n  }\n  parallel(tasks, function (err, taskResults) {\n    if (err) return cb(err);\n    var result = {};\n    if (taskResults.gasPrice) result.gasPrice = taskResults.gasPrice;\n    if (taskResults.nonce) result.nonce = taskResults.nonce.result;\n    if (taskResults.gas) result.gas = taskResults.gas;\n    cb(null, extend(txParams, result));\n  });\n};\n\n// util\n\n// we use this to clean any custom params from the txParams\nfunction cloneTxParams(txParams) {\n  return {\n    from: txParams.from,\n    to: txParams.to,\n    value: txParams.value,\n    data: txParams.data,\n    gas: txParams.gas,\n    gasPrice: txParams.gasPrice,\n    nonce: txParams.nonce\n  };\n}\nfunction toLowerCase(string) {\n  return string.toLowerCase();\n}\nfunction resemblesAddress(string) {\n  var fixed = ethUtil.addHexPrefix(string);\n  var isValid = ethUtil.isValidAddress(fixed);\n  return isValid;\n}\n\n// Returns true if resembles hex data\n// but definitely not a valid address.\nfunction resemblesData(string) {\n  var fixed = ethUtil.addHexPrefix(string);\n  var isValidAddress = ethUtil.isValidAddress(fixed);\n  return !isValidAddress && isValidHex(string);\n}\nfunction isValidHex(data) {\n  var isString = typeof data === 'string';\n  if (!isString) return false;\n  var isHexPrefixed = data.slice(0, 2) === '0x';\n  if (!isHexPrefixed) return false;\n  var nonPrefixed = data.slice(2);\n  var isValid = nonPrefixed.match(hexRegex);\n  return isValid;\n}\nfunction mustProvideInConstructor(methodName) {\n  return function (params, cb) {\n    cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide \"' + methodName + '\" fn in constructor options'));\n  };\n}","map":null,"metadata":{},"sourceType":"script"}